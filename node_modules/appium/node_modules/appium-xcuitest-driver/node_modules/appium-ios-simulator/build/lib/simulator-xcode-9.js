"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("source-map-support/register");

var _simulatorXcode = _interopRequireDefault(require("./simulator-xcode-8"));

var _lodash = _interopRequireDefault(require("lodash"));

var _path = _interopRequireDefault(require("path"));

var _appiumSupport = require("appium-support");

var _asyncLock = _interopRequireDefault(require("async-lock"));

var _logger = _interopRequireDefault(require("./logger"));

var _asyncbox = require("asyncbox");

var _utils = require("./utils.js");

const SIMULATOR_SHUTDOWN_TIMEOUT = 15 * 1000;
const startupLock = new _asyncLock.default();
const preferencesPlistGuard = new _asyncLock.default();
const ENROLLMENT_NOTIFICATION_RECEIVER = 'com.apple.BiometricKit.enrollmentChanged';

class SimulatorXcode9 extends _simulatorXcode.default {
  constructor(udid, xcodeVersion) {
    super(udid, xcodeVersion);
  }

  async run(opts = {}) {
    opts = _lodash.default.cloneDeep(opts);

    _lodash.default.defaultsDeep(opts, {
      devicePreferences: {},
      isHeadless: false,
      startupTimeout: this.startupTimeout
    });

    if (opts.scaleFactor) {
      opts.devicePreferences.SimulatorWindowLastScale = parseFloat(opts.scaleFactor);
    }

    const commonPreferences = {
      RotateWindowWhenSignaledByGuest: true
    };

    if (_lodash.default.isBoolean(opts.connectHardwareKeyboard)) {
      opts.devicePreferences.ConnectHardwareKeyboard = opts.connectHardwareKeyboard;
      commonPreferences.ConnectHardwareKeyboard = opts.connectHardwareKeyboard;
    }

    if (!_lodash.default.isEmpty(opts.devicePreferences) || !_lodash.default.isEmpty(commonPreferences)) {
      await this.updatePreferences(opts.devicePreferences, commonPreferences);
    }

    const timer = new _appiumSupport.timing.Timer().start();
    const shouldWaitForBoot = await startupLock.acquire(this.uiClientBundleId, async () => {
      const isServerRunning = await this.isRunning();
      const uiClientPid = await this.getUIClientPid();

      if (opts.isHeadless) {
        if (isServerRunning && !uiClientPid) {
          _logger.default.info(`Simulator with UDID '${this.udid}' is already booted in headless mode.`);

          return false;
        }

        if (await this.killUIClient({
          pid: uiClientPid
        })) {
          _logger.default.info(`Detected the Simulator UI client was running and killed it. Verifying the current Simulator state...`);
        }

        try {
          await (0, _asyncbox.waitForCondition)(async () => await this.isShutdown(), {
            waitMs: 5000,
            intervalMs: 100
          });
        } catch (e) {
          if (!(await this.isRunning())) {
            throw new Error(`Simulator with UDID '${this.udid}' cannot be transitioned to headless mode`);
          }

          return false;
        }

        _logger.default.info(`Booting Simulator with UDID '${this.udid}' in headless mode. All UI-related capabilities are going to be ignored`);

        await this.boot();
      } else {
        if (isServerRunning && uiClientPid) {
          _logger.default.info(`Both Simulator with UDID '${this.udid}' and the UI client are currently running`);

          return false;
        }

        if (isServerRunning) {
          _logger.default.info(`Simulator '${this.udid}' is booted while its UI is not visible. ` + `Trying to restart it with the Simulator window visible`);

          await this.shutdown({
            timeout: SIMULATOR_SHUTDOWN_TIMEOUT
          });
        }

        await this.launchWindow(uiClientPid, opts);
      }

      return true;
    });

    if (shouldWaitForBoot) {
      await this.waitForBoot(opts.startupTimeout);

      _logger.default.info(`Simulator with UDID ${this.udid} booted in ${timer.getDuration().asSeconds.toFixed(3)}s`);
    }
  }

  async launchWindow(isUiClientRunning, opts = {}) {
    await this.boot();

    if (!isUiClientRunning) {
      await this.startUIClient(opts);
    }
  }

  async boot() {
    if (await this.isRunning()) {
      _logger.default.info(`Simulator '${this.udid}' is already running`);

      return;
    }

    _logger.default.info(`Booting Simulator with UDID '${this.udid}'...`);

    try {
      await (0, _asyncbox.retryInterval)(3, 2000, async () => {
        try {
          await this.simctl.bootDevice();
        } catch (e) {
          if (!_lodash.default.includes(e.stderr, 'Unable to boot device in current state: Booted')) {
            throw e;
          }

          _logger.default.debug(`Simulator with UDID '${this.udid}' is already in Booted state`);
        }
      });
    } catch (err) {
      _logger.default.warn(err.stderr || err.message);
    }
  }

  verifyDevicePreferences(prefs = {}) {
    if (_lodash.default.isEmpty(prefs)) {
      return;
    }

    if (!_lodash.default.isUndefined(prefs.SimulatorWindowLastScale)) {
      if (!_lodash.default.isNumber(prefs.SimulatorWindowLastScale) || prefs.SimulatorWindowLastScale <= 0) {
        _logger.default.errorAndThrow(`SimulatorWindowLastScale is expected to be a positive float value. ` + `'${prefs.SimulatorWindowLastScale}' is assigned instead.`);
      }
    }

    if (!_lodash.default.isUndefined(prefs.SimulatorWindowCenter)) {
      const verificationPattern = /{-?\d+(\.\d+)?,-?\d+(\.\d+)?}/;

      if (!_lodash.default.isString(prefs.SimulatorWindowCenter) || !verificationPattern.test(prefs.SimulatorWindowCenter)) {
        _logger.default.errorAndThrow(`SimulatorWindowCenter is expected to match "{floatXPosition,floatYPosition}" format (without spaces). ` + `'${prefs.SimulatorWindowCenter}' is assigned instead.`);
      }
    }

    if (!_lodash.default.isUndefined(prefs.SimulatorWindowOrientation)) {
      const acceptableValues = ['Portrait', 'LandscapeLeft', 'PortraitUpsideDown', 'LandscapeRight'];

      if (acceptableValues.indexOf(prefs.SimulatorWindowOrientation) === -1) {
        _logger.default.errorAndThrow(`SimulatorWindowOrientation is expected to be one of ${acceptableValues}. ` + `'${prefs.SimulatorWindowOrientation}' is assigned instead.`);
      }
    }

    if (!_lodash.default.isUndefined(prefs.SimulatorWindowRotationAngle)) {
      if (!_lodash.default.isNumber(prefs.SimulatorWindowRotationAngle)) {
        _logger.default.errorAndThrow(`SimulatorWindowRotationAngle is expected to be a valid number. ` + `'${prefs.SimulatorWindowRotationAngle}' is assigned instead.`);
      }
    }
  }

  async updatePreferences(devicePrefs = {}, commonPrefs = {}) {
    if (!_lodash.default.isEmpty(devicePrefs)) {
      _logger.default.debug(`Setting preferences of ${this.udid} Simulator to ${JSON.stringify(devicePrefs)}`);
    }

    if (!_lodash.default.isEmpty(commonPrefs)) {
      _logger.default.debug(`Setting common Simulator preferences to ${JSON.stringify(commonPrefs)}`);
    }

    const homeFolderPath = process.env.HOME;

    if (!homeFolderPath) {
      _logger.default.warn(`Cannot get the path to HOME folder from the process environment. ` + `Ignoring Simulator preferences update.`);

      return false;
    }

    this.verifyDevicePreferences(devicePrefs);

    const plistPath = _path.default.resolve(homeFolderPath, 'Library', 'Preferences', 'com.apple.iphonesimulator.plist');

    if (!(await _appiumSupport.fs.hasAccess(plistPath))) {
      _logger.default.warn(`Simulator preferences file '${plistPath}' is not accessible. ` + `Ignoring Simulator preferences update.`);

      return false;
    }

    let newPrefs = {};

    if (!_lodash.default.isEmpty(devicePrefs)) {
      newPrefs.DevicePreferences = {
        [this.udid.toUpperCase()]: devicePrefs
      };
    }

    newPrefs = _lodash.default.merge(newPrefs, commonPrefs);
    return await preferencesPlistGuard.acquire(SimulatorXcode9.name, async () => {
      try {
        const currentPlistContent = await _appiumSupport.plist.parsePlistFile(plistPath);
        await _appiumSupport.plist.updatePlistFile(plistPath, _lodash.default.merge(currentPlistContent, newPrefs), true);

        _logger.default.debug(`Updated ${this.udid} Simulator preferences at '${plistPath}' with ${JSON.stringify(newPrefs)}`);

        return true;
      } catch (e) {
        _logger.default.warn(`Cannot update ${this.udid} Simulator preferences at '${plistPath}'. ` + `Try to delete the file manually in order to reset it. Original error: ${e.message}`);

        return false;
      }
    });
  }

  async shutdown(opts = {}) {
    if (await this.isRunning()) {
      await (0, _asyncbox.retryInterval)(5, 500, this.simctl.shutdownDevice.bind(this.simctl));
      const {
        timeout
      } = opts;
      const waitMs = parseInt(timeout, 10);

      if (waitMs > 0) {
        try {
          await (0, _asyncbox.waitForCondition)(async () => await this.isShutdown(), {
            waitMs,
            intervalMs: 100
          });
        } catch (err) {
          throw new Error(`Simulator is not in 'Shutdown' state after ${waitMs}ms`);
        }
      }
    }
  }

  async clean() {
    _logger.default.info(`Cleaning simulator ${this.udid}`);

    await this.simctl.eraseDevice(10000);
  }

  async _activateWindow() {
    let selfName;
    let selfSdk;
    let bootedDevicesCount = 0;

    for (const [sdk, deviceArr] of _lodash.default.toPairs(await this.simctl.getDevices())) {
      for (const {
        state,
        udid,
        name
      } of deviceArr) {
        if (state === 'Booted') {
          bootedDevicesCount++;
        }

        if (!selfName && udid === this.udid) {
          selfSdk = sdk;
          selfName = name;
        }
      }
    }

    if (bootedDevicesCount < 2) {
      return await super._activateWindow();
    }

    return `
      tell application "System Events"
        tell process "Simulator"
          set frontmost to false
          set frontmost to true
          click (menu item 1 where (its name contains "${selfName} " and its name contains "${selfSdk}")) of menu 1 of menu bar item "Window" of menu bar 1
        end tell
      end tell
    `;
  }

  async isBiometricEnrolled() {
    const {
      stdout
    } = await this.simctl.spawnProcess(['notifyutil', '-g', ENROLLMENT_NOTIFICATION_RECEIVER]);
    const match = new RegExp(`${_lodash.default.escapeRegExp(ENROLLMENT_NOTIFICATION_RECEIVER)}\\s+([01])`).exec(stdout);

    if (!match) {
      throw new Error(`Cannot parse biometric enrollment state from '${stdout}'`);
    }

    _logger.default.info(`Current biometric enrolled state for ${this.udid} Simulator: ${match[1]}`);

    return match[1] === '1';
  }

  async enrollBiometric(isEnabled = true) {
    _logger.default.debug(`Setting biometric enrolled state for ${this.udid} Simulator to '${isEnabled ? 'enabled' : 'disabled'}'`);

    await this.simctl.spawnProcess(['notifyutil', '-s', ENROLLMENT_NOTIFICATION_RECEIVER, isEnabled ? '1' : '0']);
    await this.simctl.spawnProcess(['notifyutil', '-p', ENROLLMENT_NOTIFICATION_RECEIVER]);

    if ((await this.isBiometricEnrolled()) !== isEnabled) {
      throw new Error(`Cannot set biometric enrolled state for ${this.udid} Simulator to '${isEnabled ? 'enabled' : 'disabled'}'`);
    }
  }

  async sendBiometricMatch(shouldMatch = true, biometricName = 'touchId') {
    const domainComponent = (0, _utils.toBiometricDomainComponent)(biometricName);
    const domain = `com.apple.BiometricKit_Sim.${domainComponent}.${shouldMatch ? '' : 'no'}match`;
    await this.simctl.spawnProcess(['notifyutil', '-p', domain]);

    _logger.default.info(`Sent notification ${domain} to ${shouldMatch ? 'match' : 'not match'} ${biometricName} biometric ` + `for ${this.udid} Simulator`);
  }

  async getLaunchDaemonsRoot() {
    const devRoot = await (0, _utils.getDeveloperRoot)();
    return _path.default.resolve(devRoot, 'Platforms/iPhoneOS.platform/Developer/Library/CoreSimulator/Profiles/Runtimes/iOS.simruntime/Contents/Resources/RuntimeRoot/System/Library/LaunchDaemons');
  }

}

var _default = SimulatorXcode9;
exports.default = _default;require('source-map-support').install();


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9zaW11bGF0b3IteGNvZGUtOS5qcyJdLCJuYW1lcyI6WyJTSU1VTEFUT1JfU0hVVERPV05fVElNRU9VVCIsInN0YXJ0dXBMb2NrIiwiQXN5bmNMb2NrIiwicHJlZmVyZW5jZXNQbGlzdEd1YXJkIiwiRU5ST0xMTUVOVF9OT1RJRklDQVRJT05fUkVDRUlWRVIiLCJTaW11bGF0b3JYY29kZTkiLCJTaW11bGF0b3JYY29kZTgiLCJjb25zdHJ1Y3RvciIsInVkaWQiLCJ4Y29kZVZlcnNpb24iLCJydW4iLCJvcHRzIiwiXyIsImNsb25lRGVlcCIsImRlZmF1bHRzRGVlcCIsImRldmljZVByZWZlcmVuY2VzIiwiaXNIZWFkbGVzcyIsInN0YXJ0dXBUaW1lb3V0Iiwic2NhbGVGYWN0b3IiLCJTaW11bGF0b3JXaW5kb3dMYXN0U2NhbGUiLCJwYXJzZUZsb2F0IiwiY29tbW9uUHJlZmVyZW5jZXMiLCJSb3RhdGVXaW5kb3dXaGVuU2lnbmFsZWRCeUd1ZXN0IiwiaXNCb29sZWFuIiwiY29ubmVjdEhhcmR3YXJlS2V5Ym9hcmQiLCJDb25uZWN0SGFyZHdhcmVLZXlib2FyZCIsImlzRW1wdHkiLCJ1cGRhdGVQcmVmZXJlbmNlcyIsInRpbWVyIiwidGltaW5nIiwiVGltZXIiLCJzdGFydCIsInNob3VsZFdhaXRGb3JCb290IiwiYWNxdWlyZSIsInVpQ2xpZW50QnVuZGxlSWQiLCJpc1NlcnZlclJ1bm5pbmciLCJpc1J1bm5pbmciLCJ1aUNsaWVudFBpZCIsImdldFVJQ2xpZW50UGlkIiwibG9nIiwiaW5mbyIsImtpbGxVSUNsaWVudCIsInBpZCIsImlzU2h1dGRvd24iLCJ3YWl0TXMiLCJpbnRlcnZhbE1zIiwiZSIsIkVycm9yIiwiYm9vdCIsInNodXRkb3duIiwidGltZW91dCIsImxhdW5jaFdpbmRvdyIsIndhaXRGb3JCb290IiwiZ2V0RHVyYXRpb24iLCJhc1NlY29uZHMiLCJ0b0ZpeGVkIiwiaXNVaUNsaWVudFJ1bm5pbmciLCJzdGFydFVJQ2xpZW50Iiwic2ltY3RsIiwiYm9vdERldmljZSIsImluY2x1ZGVzIiwic3RkZXJyIiwiZGVidWciLCJlcnIiLCJ3YXJuIiwibWVzc2FnZSIsInZlcmlmeURldmljZVByZWZlcmVuY2VzIiwicHJlZnMiLCJpc1VuZGVmaW5lZCIsImlzTnVtYmVyIiwiZXJyb3JBbmRUaHJvdyIsIlNpbXVsYXRvcldpbmRvd0NlbnRlciIsInZlcmlmaWNhdGlvblBhdHRlcm4iLCJpc1N0cmluZyIsInRlc3QiLCJTaW11bGF0b3JXaW5kb3dPcmllbnRhdGlvbiIsImFjY2VwdGFibGVWYWx1ZXMiLCJpbmRleE9mIiwiU2ltdWxhdG9yV2luZG93Um90YXRpb25BbmdsZSIsImRldmljZVByZWZzIiwiY29tbW9uUHJlZnMiLCJKU09OIiwic3RyaW5naWZ5IiwiaG9tZUZvbGRlclBhdGgiLCJwcm9jZXNzIiwiZW52IiwiSE9NRSIsInBsaXN0UGF0aCIsInBhdGgiLCJyZXNvbHZlIiwiZnMiLCJoYXNBY2Nlc3MiLCJuZXdQcmVmcyIsIkRldmljZVByZWZlcmVuY2VzIiwidG9VcHBlckNhc2UiLCJtZXJnZSIsIm5hbWUiLCJjdXJyZW50UGxpc3RDb250ZW50IiwicGxpc3QiLCJwYXJzZVBsaXN0RmlsZSIsInVwZGF0ZVBsaXN0RmlsZSIsInNodXRkb3duRGV2aWNlIiwiYmluZCIsInBhcnNlSW50IiwiY2xlYW4iLCJlcmFzZURldmljZSIsIl9hY3RpdmF0ZVdpbmRvdyIsInNlbGZOYW1lIiwic2VsZlNkayIsImJvb3RlZERldmljZXNDb3VudCIsInNkayIsImRldmljZUFyciIsInRvUGFpcnMiLCJnZXREZXZpY2VzIiwic3RhdGUiLCJpc0Jpb21ldHJpY0Vucm9sbGVkIiwic3Rkb3V0Iiwic3Bhd25Qcm9jZXNzIiwibWF0Y2giLCJSZWdFeHAiLCJlc2NhcGVSZWdFeHAiLCJleGVjIiwiZW5yb2xsQmlvbWV0cmljIiwiaXNFbmFibGVkIiwic2VuZEJpb21ldHJpY01hdGNoIiwic2hvdWxkTWF0Y2giLCJiaW9tZXRyaWNOYW1lIiwiZG9tYWluQ29tcG9u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VUFBTSxLQUFLakUsTUFBTCxDQUFZMkQsWUFBWixDQUF5QixDQUM3QixZQUQ2QixFQUU3QixJQUY2QixFQUV2QmpILGdDQUZ1QixDQUF6QixDQUFOOztBQUlBLFFBQUksT0FBTSxLQUFLK0csbUJBQUwsRUFBTixNQUFxQ1EsU0FBekMsRUFBb0Q7QUFDbEQsWUFBTSxJQUFJNUUsS0FBSixDQUFXLDJDQUEwQyxLQUFLdkMsSUFBSyxrQkFBaUJtSCxTQUFTLEdBQUcsU0FBSCxHQUFlLFVBQVcsR0FBbkgsQ0FBTjtBQUNEO0FBQ0Y7O0FBVUQsUUFBTUMsa0JBQU4sQ0FBMEJDLFdBQVcsR0FBRyxJQUF4QyxFQUE4Q0MsYUFBYSxHQUFHLFNBQTlELEVBQXlFO0FBQ3ZFLFVBQU1DLGVBQWUsR0FBRyx1Q0FBMkJELGFBQTNCLENBQXhCO0FBQ0EsVUFBTUUsTUFBTSxHQUFJLDhCQUE2QkQsZUFBZ0IsSUFBR0YsV0FBVyxHQUFHLEVBQUgsR0FBUSxJQUFLLE9BQXhGO0FBQ0EsVUFBTSxLQUFLbkUsTUFBTCxDQUFZMkQsWUFBWixDQUF5QixDQUM3QixZQUQ2QixFQUU3QixJQUY2QixFQUV2QlcsTUFGdUIsQ0FBekIsQ0FBTjs7QUFJQXpGLG9CQUFJQyxJQUFKLENBQVUscUJBQW9Cd0YsTUFBTyxPQUFNSCxXQUFXLEdBQUcsT0FBSCxHQUFhLFdBQVksSUFBR0MsYUFBYyxhQUF2RixHQUNOLE9BQU0sS0FBS3RILElBQUssWUFEbkI7QUFFRDs7QUFLRCxRQUFNeUgsb0JBQU4sR0FBOEI7QUFDNUIsVUFBTUMsT0FBTyxHQUFHLE1BQU0sOEJBQXRCO0FBQ0EsV0FBTzFDLGNBQUtDLE9BQUwsQ0FBYXlDLE9BQWIsRUFDTCwwSkFESyxDQUFQO0FBRUQ7O0FBNVkyQzs7ZUFnWi9CN0gsZSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBTaW11bGF0b3JYY29kZTggZnJvbSAnLi9zaW11bGF0b3IteGNvZGUtOCc7XG5pbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgeyBmcywgcGxpc3QsIHRpbWluZyB9IGZyb20gJ2FwcGl1bS1zdXBwb3J0JztcbmltcG9ydCBBc3luY0xvY2sgZnJvbSAnYXN5bmMtbG9jayc7XG5pbXBvcnQgbG9nIGZyb20gJy4vbG9nZ2VyJztcbmltcG9ydCB7IHdhaXRGb3JDb25kaXRpb24sIHJldHJ5SW50ZXJ2YWwgfSBmcm9tICdhc3luY2JveCc7XG5pbXBvcnQgeyB0b0Jpb21ldHJpY0RvbWFpbkNvbXBvbmVudCwgZ2V0RGV2ZWxvcGVyUm9vdCB9IGZyb20gJy4vdXRpbHMuanMnO1xuXG5jb25zdCBTSU1VTEFUT1JfU0hVVERPV05fVElNRU9VVCA9IDE1ICogMTAwMDtcbmNvbnN0IHN0YXJ0dXBMb2NrID0gbmV3IEFzeW5jTG9jaygpO1xuY29uc3QgcHJlZmVyZW5jZXNQbGlzdEd1YXJkID0gbmV3IEFzeW5jTG9jaygpO1xuY29uc3QgRU5ST0xMTUVOVF9OT1RJRklDQVRJT05fUkVDRUlWRVIgPSAnY29tLmFwcGxlLkJpb21ldHJpY0tpdC5lbnJvbGxtZW50Q2hhbmdlZCc7XG5cbmNsYXNzIFNpbXVsYXRvclhjb2RlOSBleHRlbmRzIFNpbXVsYXRvclhjb2RlOCB7XG4gIGNvbnN0cnVjdG9yICh1ZGlkLCB4Y29kZVZlcnNpb24pIHtcbiAgICBzdXBlcih1ZGlkLCB4Y29kZVZlcnNpb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IERldmljZVByZWZlcmVuY2VzXG4gICAqIEBwcm9wZXJ0eSB7P251bWJlcn0gU2ltdWxhdG9yRXh0ZXJuYWxEaXNwbGF5IC0gVEJELiBFeGFtcGxlIHZhbHVlOiAyLjExNFxuICAgKiBAcHJvcGVydHkgez9zdHJpbmd9IENocm9tZVRpbnQgLSBUQkQuIEV4YW1wbGUgdmFsdWU6ICcnXG4gICAqIEBwcm9wZXJ0eSB7P251bWJlcn0gU2ltdWxhdG9yV2luZG93TGFzdFNjYWxlIC0gU2NhbGUgdmFsdWUgZm9yIHRoZSBwYXJ0aWN1bGFyIFNpbXVsYXRvciB3aW5kb3cuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMS4wIG1lYW5zIDEwMCUgc2NhbGUuXG4gICAqIEBwcm9wZXJ0eSB7P3N0cmluZ30gU2ltdWxhdG9yV2luZG93T3JpZW50YXRpb24gLSBTaW11bGF0b3Igd2luZG93IG9yaWVudGF0aW9uLiBQb3NzaWJsZSB2YWx1ZXMgYXJlOlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1BvcnRyYWl0JywgJ0xhbmRzY2FwZUxlZnQnLCAnUG9ydHJhaXRVcHNpZGVEb3duJyBhbmQgJ0xhbmRzY2FwZVJpZ2h0Jy5cbiAgICogQHByb3BlcnR5IHs/bnVtYmVyfSBTaW11bGF0b3JXaW5kb3dSb3RhdGlvbkFuZ2xlIC0gV2luZG93IHJvdGF0aW9uIGFuZ2xlLiBUaGlzIHZhbHVlIGlzIGV4cGVjdGVkIHRvIGJlIGluIHN5bmNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2l0aCBfU2ltdWxhdG9yV2luZG93T3JpZW50YXRpb25fLiBUaGUgY29ycmVzcG9uZGluZyB2YWx1ZXMgYXJlOlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLCA5MCwgMTgwIGFuZCAyNzAuXG4gICAqIEBwcm9wZXJ0eSB7P3N0cmluZ30gU2ltdWxhdG9yV2luZG93Q2VudGVyIC0gVGhlIGNvb3JkaW5hdGVzIG9mIFNpbXVsYXRvcidzIHdpbmRvdyBjZW50ZXIgaW4gcGl4ZWxzLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciBleGFtcGxlICd7LTEyOTQuNSwgNzc1LjV9Jy5cbiAgICogQHByb3BlcnR5IHs/Ym9vbGVhbn0gQ29ubmVjdEhhcmR3YXJlS2V5Ym9hcmQgLSBFcXVhbHMgdG8gMSBpZiBoYXJkd2FyZSBrZXlib2FyZCBzaG91bGQgYmUgY29ubmVjdGVkLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE90aGVyd2lzZSAwLlxuICAgKi9cblxuICAvKipcbiAgICogQHR5cGVkZWYge09iamVjdH0gQ29tbW9uUHJlZmVyZW5jZXNcbiAgICogQHByb3BlcnR5IHtib29sZWFufSBDb25uZWN0SGFyZHdhcmVLZXlib2FyZCAtIFdoZXRoZXIgdG8gY29ubmVjdCBoYXJkd2FyZSBrZXlib2FyZFxuICAgKi9cblxuICAvKipcbiAgICogQHR5cGVkZWYge09iamVjdH0gUnVuT3B0aW9uc1xuICAgKiBAcHJvcGVydHkge3N0cmluZ30gc2NhbGVGYWN0b3I6IEFueSBwb3NpdGl2ZSBmbG9hdCB2YWx1ZS4gMS4wIG1lYW5zIDE6MSBzY2FsZS5cbiAgICogRGVmaW5lcyB0aGUgd2luZG93IHNjYWxlIHZhbHVlIGZvciB0aGUgVUkgY2xpZW50IHdpbmRvdyBmb3IgdGhlIGN1cnJlbnQgU2ltdWxhdG9yLlxuICAgKiBFcXVhbHMgdG8gYG51bGxgIGJ5IGRlZmF1bHQsIHdoaWNoIGtlZXBzIHRoZSBjdXJyZW50IHNjYWxlIHVuY2hhbmdlZC5cbiAgICogQHByb3BlcnR5IHtib29sZWFufSBjb25uZWN0SGFyZHdhcmVLZXlib2FyZDogd2hldGhlciB0byBjb25uZWN0IHRoZSBoYXJkd2FyZSBrZXlib2FyZCB0byB0aGVcbiAgICogU2ltdWxhdG9yIFVJIGNsaWVudC4gRXF1YWxzIHRvIGBmYWxzZWAgYnkgZGVmYXVsdC5cbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IHN0YXJ0dXBUaW1lb3V0OiBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHdhaXQgdW50aWwgU2ltdWxhdG9yIGJvb3RpbmdcbiAgICogcHJvY2VzcyBpcyBjb21wbGV0ZWQuIFRoZSBkZWZhdWx0IHRpbWVvdXQgd2lsbCBiZSB1c2VkIGlmIG5vdCBzZXQgZXhwbGljaXRseS5cbiAgICogQHByb3BlcnR5IHtib29sZWFufSBpc0hlYWRsZXNzOiB3aGV0aGVyIHRvIHN0YXJ0IHRoZSBTaW11bGF0b3IgaW4gaGVhZGxlc3MgbW9kZSAod2l0aCBVSVxuICAgKiBjbGllbnQgaW52aXNpYmxlKS4gYGZhbHNlYCBieSBkZWZhdWx0LlxuICAgKiBAcHJvcGVydHkgez9ib29sZWFufSB0cmFjZVBvaW50ZXIgW2ZhbHNlXSAtIFdoZXRoZXIgdG8gaGlnaGxpZ2h0IHRvdWNoZXMgb24gU2ltdWxhdG9yXG4gICAqIHNjcmVlbi4gVGhpcyBpcyBoZWxwZnVsIHdoaWxlIGRlYnVnZ2luZyBhdXRvbWF0ZWQgdGVzdHMgb3Igd2hpbGUgb2JzZXJ2aW5nIHRoZSBhdXRvbWF0aW9uXG4gICAqIHJlY29yZGluZ3MuXG4gICAqIEBwcm9wZXJ0eSB7RGV2aWNlUHJlZmVyZW5jZXN9IGRldmljZVByZWZlcmVuY2VzOiBwcmVmZXJlbmNlcyBvZiB0aGUgbmV3bHkgY3JlYXRlZCBTaW11bGF0b3JcbiAgICogZGV2aWNlXG4gICAqL1xuXG4gIC8qKlxuICAgKiBFeGVjdXRlcyBnaXZlbiBTaW11bGF0b3Igd2l0aCBvcHRpb25zLiBUaGUgU2ltdWxhdG9yIHdpbGwgbm90IGJlIHJlc3RhcnRlZCBpZlxuICAgKiBpdCBpcyBhbHJlYWR5IHJ1bm5pbmcgYW5kIHRoZSBjdXJyZW50IFVJIHN0YXRlIG1hdGNoZXMgdG8gYGlzSGVhZGxlc3NgIG9wdGlvbi5cbiAgICogQG92ZXJyaWRlXG4gICAqXG4gICAqIEBwYXJhbSB7UnVuT3B0aW9uc30gb3B0cyAtIE9uZSBvciBtb3JlIG9mIGF2YWlsYWJsZSBTaW11bGF0b3Igb3B0aW9uc1xuICAgKi9cbiAgYXN5bmMgcnVuIChvcHRzID0ge30pIHtcbiAgICBvcHRzID0gXy5jbG9uZURlZXAob3B0cyk7XG4gICAgXy5kZWZhdWx0c0RlZXAob3B0cywge1xuICAgICAgZGV2aWNlUHJlZmVyZW5jZXM6IHt9LFxuICAgICAgaXNIZWFkbGVzczogZmFsc2UsXG4gICAgICBzdGFydHVwVGltZW91dDogdGhpcy5zdGFydHVwVGltZW91dCxcbiAgICB9KTtcbiAgICBpZiAob3B0cy5zY2FsZUZhY3Rvcikge1xuICAgICAgb3B0cy5kZXZpY2VQcmVmZXJlbmNlcy5TaW11bGF0b3JXaW5kb3dMYXN0U2NhbGUgPSBwYXJzZUZsb2F0KG9wdHMuc2NhbGVGYWN0b3IpO1xuICAgIH1cbiAgICAvLyBUaGlzIG9wdGlvbiBpcyBuZWNlc3NhcnkgdG8gbWFrZSB0aGUgU2ltdWxhdG9yIHdpbmRvdyBmb2xsb3dcbiAgICAvLyB0aGUgYWN0dWFsIFhDVUlEZXZpY2Ugb3JpZW50YXRpb25cbiAgICBjb25zdCBjb21tb25QcmVmZXJlbmNlcyA9IHtcbiAgICAgIFJvdGF0ZVdpbmRvd1doZW5TaWduYWxlZEJ5R3Vlc3Q6IHRydWVcbiAgICB9O1xuICAgIGlmIChfLmlzQm9vbGVhbihvcHRzLmNvbm5lY3RIYXJkd2FyZUtleWJvYXJkKSkge1xuICAgICAgb3B0cy5kZXZpY2VQcmVmZXJlbmNlcy5Db25uZWN0SGFyZHdhcmVLZXlib2FyZCA9IG9wdHMuY29ubmVjdEhhcmR3YXJlS2V5Ym9hcmQ7XG4gICAgICBjb21tb25QcmVmZXJlbmNlcy5Db25uZWN0SGFyZHdhcmVLZXlib2FyZCA9IG9wdHMuY29ubmVjdEhhcmR3YXJlS2V5Ym9hcmQ7XG4gICAgfVxuICAgIGlmICghXy5pc0VtcHR5KG9wdHMuZGV2aWNlUHJlZmVyZW5jZXMpIHx8ICFfLmlzRW1wdHkoY29tbW9uUHJlZmVyZW5jZXMpKSB7XG4gICAgICBhd2FpdCB0aGlzLnVwZGF0ZVByZWZlcmVuY2VzKG9wdHMuZGV2aWNlUHJlZmVyZW5jZXMsIGNvbW1vblByZWZlcmVuY2VzKTtcbiAgICB9XG4gICAgY29uc3QgdGltZXIgPSBuZXcgdGltaW5nLlRpbWVyKCkuc3RhcnQoKTtcbiAgICBjb25zdCBzaG91bGRXYWl0Rm9yQm9vdCA9IGF3YWl0IHN0YXJ0dXBMb2NrLmFjcXVpcmUodGhpcy51aUNsaWVudEJ1bmRsZUlkLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBpc1NlcnZlclJ1bm5pbmcgPSBhd2FpdCB0aGlzLmlzUnVubmluZygpO1xuICAgICAgY29uc3QgdWlDbGllbnRQaWQgPSBhd2FpdCB0aGlzLmdldFVJQ2xpZW50UGlkKCk7XG4gICAgICBpZiAob3B0cy5pc0hlYWRsZXNzKSB7XG4gICAgICAgIGlmIChpc1NlcnZlclJ1bm5pbmcgJiYgIXVpQ2xpZW50UGlkKSB7XG4gICAgICAgICAgbG9nLmluZm8oYFNpbXVsYXRvciB3aXRoIFVESUQgJyR7dGhpcy51ZGlkfScgaXMgYWxyZWFkeSBib290ZWQgaW4gaGVhZGxlc3MgbW9kZS5gKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF3YWl0IHRoaXMua2lsbFVJQ2xpZW50KHtwaWQ6IHVpQ2xpZW50UGlkfSkpIHtcbiAgICAgICAgICBsb2cuaW5mbyhgRGV0ZWN0ZWQgdGhlIFNpbXVsYXRvciBVSSBjbGllbnQgd2FzIHJ1bm5pbmcgYW5kIGtpbGxlZCBpdC4gVmVyaWZ5aW5nIHRoZSBjdXJyZW50IFNpbXVsYXRvciBzdGF0ZS4uLmApO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gU3RvcHBpbmcgdGhlIFVJIGNsaWVudCBraWxscyBhbGwgcnVubmluZyBzZXJ2ZXJzIGZvciBzb21lIGVhcmx5IFhDb2RlIHZlcnNpb25zLiBUaGlzIGlzIGEga25vd24gYnVnXG4gICAgICAgICAgYXdhaXQgd2FpdEZvckNvbmRpdGlvbihhc3luYyAoKSA9PiBhd2FpdCB0aGlzLmlzU2h1dGRvd24oKSwge1xuICAgICAgICAgICAgd2FpdE1zOiA1MDAwLFxuICAgICAgICAgICAgaW50ZXJ2YWxNczogMTAwLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaWYgKCFhd2FpdCB0aGlzLmlzUnVubmluZygpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNpbXVsYXRvciB3aXRoIFVESUQgJyR7dGhpcy51ZGlkfScgY2Fubm90IGJlIHRyYW5zaXRpb25lZCB0byBoZWFkbGVzcyBtb2RlYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBsb2cuaW5mbyhgQm9vdGluZyBTaW11bGF0b3Igd2l0aCBVRElEICcke3RoaXMudWRpZH0nIGluIGhlYWRsZXNzIG1vZGUuIEFsbCBVSS1yZWxhdGVkIGNhcGFiaWxpdGllcyBhcmUgZ29pbmcgdG8gYmUgaWdub3JlZGApO1xuICAgICAgICBhd2FpdCB0aGlzLmJvb3QoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc1NlcnZlclJ1bm5pbmcgJiYgdWlDbGllbnRQaWQpIHtcbiAgICAgICAgICBsb2cuaW5mbyhgQm90aCBTaW11bGF0b3Igd2l0aCBVRElEICcke3RoaXMudWRpZH0nIGFuZCB0aGUgVUkgY2xpZW50IGFyZSBjdXJyZW50bHkgcnVubmluZ2ApO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNTZXJ2ZXJSdW5uaW5nKSB7XG4gICAgICAgICAgbG9nLmluZm8oYFNpbXVsYXRvciAnJHt0aGlzLnVkaWR9JyBpcyBib290ZWQgd2hpbGUgaXRzIFVJIGlzIG5vdCB2aXNpYmxlLiBgICtcbiAgICAgICAgICAgIGBUcnlpbmcgdG8gcmVzdGFydCBpdCB3aXRoIHRoZSBTaW11bGF0b3Igd2luZG93IHZpc2libGVgKTtcbiAgICAgICAgICBhd2FpdCB0aGlzLnNodXRkb3duKHt0aW1lb3V0OiBTSU1VTEFUT1JfU0hVVERPV05fVElNRU9VVH0pO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRoaXMubGF1bmNoV2luZG93KHVpQ2xpZW50UGlkLCBvcHRzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuXG4gICAgaWYgKHNob3VsZFdhaXRGb3JCb290KSB7XG4gICAgICBhd2FpdCB0aGlzLndhaXRGb3JCb290KG9wdHMuc3RhcnR1cFRpbWVvdXQpO1xuICAgICAgbG9nLmluZm8oYFNpbXVsYXRvciB3aXRoIFVESUQgJHt0aGlzLnVkaWR9IGJvb3RlZCBpbiAke3RpbWVyLmdldER1cmF0aW9uKCkuYXNTZWNvbmRzLnRvRml4ZWQoMyl9c2ApO1xuICAgIH1cbiAgfVxuXG4gIC8qKipcbiAgICogQm9vdHMgc2ltdWxhdG9yIGFuZCBvcGVucyBzaW11bGF0b3JzIFVJIENsaWVudCBpZiBub3QgYWxyZWFkeSBvcGVuZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNVaUNsaWVudFJ1bm5pbmcgLSBwcm9jZXNzIGlkIG9mIHNpbXVsYXRvciBVSSBjbGllbnQuXG4gICAqIEBwYXJhbSB7UnVuT3B0aW9uc30gb3B0cyAtIGFyZ3VtZW50cyB0byBzdGFydCBzaW11bGF0b3IgVUkgY2xpZW50IHdpdGguXG4gICAqL1xuICBhc3luYyBsYXVuY2hXaW5kb3cgKGlzVWlDbGllbnRSdW5uaW5nLCBvcHRzID0ge30pIHtcbiAgICBhd2FpdCB0aGlzLmJvb3QoKTtcbiAgICBpZiAoIWlzVWlDbGllbnRSdW5uaW5nKSB7XG4gICAgICBhd2FpdCB0aGlzLnN0YXJ0VUlDbGllbnQob3B0cyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEJvb3RzIHNpbXVsYXRvciBpZiBub3QgYWxyZWFkeSBib290ZWQuXG4gICAqL1xuICBhc3luYyBib290ICgpIHtcbiAgICBpZiAoYXdhaXQgdGhpcy5pc1J1bm5pbmcoKSkge1xuICAgICAgbG9nLmluZm8oYFNpbXVsYXRvciAnJHt0aGlzLnVkaWR9JyBpcyBhbHJlYWR5IHJ1bm5pbmdgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsb2cuaW5mbyhgQm9vdGluZyBTaW11bGF0b3Igd2l0aCBVRElEICcke3RoaXMudWRpZH0nLi4uYCk7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHJldHJ5SW50ZXJ2YWwoMywgMjAwMCwgYXN5bmMgKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGF3YWl0IHRoaXMuc2ltY3RsLmJvb3REZXZpY2UoKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGlmICghXy5pbmNsdWRlcyhlLnN0ZGVyciwgJ1VuYWJsZSB0byBib290IGRldmljZSBpbiBjdXJyZW50IHN0YXRlOiBCb290ZWQnKSkge1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbG9nLmRlYnVnKGBTaW11bGF0b3Igd2l0aCBVRElEICcke3RoaXMudWRpZH0nIGlzIGFscmVhZHkgaW4gQm9vdGVkIHN0YXRlYCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgbG9nLndhcm4oZXJyLnN0ZGVyciB8fCBlcnIubWVzc2FnZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFBlcmZvcm0gdmVyaWZpY2F0aW9uIG9mIGRldmljZSBwcmVmZXJlbmNlcyBjb3JyZWN0bmVzcy5cbiAgICpcbiAgICogQHBhcmFtIHtEZXZpY2VQcmVmZXJlbmNlc30gcHJlZnMgW3t9XSAtIFRoZSBwcmVmZXJlbmNlcyB0byBiZSB2ZXJpZmllZFxuICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgYW55IG9mIHRoZSBnaXZlbiBwcmVmZXJlbmNlIHZhbHVlcyBkb2VzIG5vdCBtYXRjaCB0aGUgZXhwZWN0ZWRcbiAgICogZm9ybWF0LlxuICAgKi9cbiAgdmVyaWZ5RGV2aWNlUHJlZmVyZW5jZXMgKHByZWZzID0ge30pIHtcbiAgICBpZiAoXy5pc0VtcHR5KHByZWZzKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghXy5pc1VuZGVmaW5lZChwcmVmcy5TaW11bGF0b3JXaW5kb3dMYXN0U2NhbGUpKSB7XG4gICAgICBpZiAoIV8uaXNOdW1iZXIocHJlZnMuU2ltdWxhdG9yV2luZG93TGFzdFNjYWxlKSB8fCBwcmVmcy5TaW11bGF0b3JXaW5kb3dMYXN0U2NhbGUgPD0gMCkge1xuICAgICAgICBsb2cuZXJyb3JBbmRUaHJvdyhgU2ltdWxhdG9yV2luZG93TGFzdFNjYWxlIGlzIGV4cGVjdGVkIHRvIGJlIGEgcG9zaXRpdmUgZmxvYXQgdmFsdWUuIGAgK1xuICAgICAgICAgIGAnJHtwcmVmcy5TaW11bGF0b3JXaW5kb3dMYXN0U2NhbGV9JyBpcyBhc3NpZ25lZCBpbnN0ZWFkLmApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghXy5pc1VuZGVmaW5lZChwcmVmcy5TaW11bGF0b3JXaW5kb3dDZW50ZXIpKSB7XG4gICAgICAvLyBodHRwczovL3JlZ2V4MTAxLmNvbS9yLzJaWE9pai8yXG4gICAgICBjb25zdCB2ZXJpZmljYXRpb25QYXR0ZXJuID0gL3stP1xcZCsoXFwuXFxkKyk/LC0/XFxkKyhcXC5cXGQrKT99LztcbiAgICAgIGlmICghXy5pc1N0cmluZyhwcmVmcy5TaW11bGF0b3JXaW5kb3dDZW50ZXIpIHx8ICF2ZXJpZmljYXRpb25QYXR0ZXJuLnRlc3QocHJlZnMuU2ltdWxhdG9yV2luZG93Q2VudGVyKSkge1xuICAgICAgICBsb2cuZXJyb3JBbmRUaHJvdyhgU2ltdWxhdG9yV2luZG93Q2VudGVyIGlzIGV4cGVjdGVkIHRvIG1hdGNoIFwie2Zsb2F0WFBvc2l0aW9uLGZsb2F0WVBvc2l0aW9ufVwiIGZvcm1hdCAod2l0aG91dCBzcGFjZXMpLiBgICtcbiAgICAgICAgICBgJyR7cHJlZnMuU2ltdWxhdG9yV2luZG93Q2VudGVyfScgaXMgYXNzaWduZWQgaW5zdGVhZC5gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIV8uaXNVbmRlZmluZWQocHJlZnMuU2ltdWxhdG9yV2luZG93T3JpZW50YXRpb24pKSB7XG4gICAgICBjb25zdCBhY2NlcHRhYmxlVmFsdWVzID0gWydQb3J0cmFpdCcsICdMYW5kc2NhcGVMZWZ0JywgJ1BvcnRyYWl0VXBzaWRlRG93bicsICdMYW5kc2NhcGVSaWdodCddO1xuICAgICAgaWYgKGFjY2VwdGFibGVWYWx1ZXMuaW5kZXhPZihwcmVmcy5TaW11bGF0b3JXaW5kb3dPcmllbnRhdGlvbikgPT09IC0xKSB7XG4gICAgICAgIGxvZy5lcnJvckFuZFRocm93KGBTaW11bGF0b3JXaW5kb3dPcmllbnRhdGlvbiBpcyBleHBlY3RlZCB0byBiZSBvbmUgb2YgJHthY2NlcHRhYmxlVmFsdWVzfS4gYCArXG4gICAgICAgICAgYCcke3ByZWZzLlNpbXVsYXRvcldpbmRvd09yaWVudGF0aW9ufScgaXMgYXNzaWduZWQgaW5zdGVhZC5gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIV8uaXNVbmRlZmluZWQocHJlZnMuU2ltdWxhdG9yV2luZG93Um90YXRpb25BbmdsZSkpIHtcbiAgICAgIGlmICghXy5pc051bWJlcihwcmVmcy5TaW11bGF0b3JXaW5kb3dSb3RhdGlvbkFuZ2xlKSkge1xuICAgICAgICBsb2cuZXJyb3JBbmRUaHJvdyhgU2ltdWxhdG9yV2luZG93Um90YXRpb25BbmdsZSBpcyBleHBlY3RlZCB0byBiZSBhIHZhbGlkIG51bWJlci4gYCArXG4gICAgICAgICAgYCcke3ByZWZzLlNpbXVsYXRvcldpbmRvd1JvdGF0aW9uQW5nbGV9JyBpcyBhc3NpZ25lZCBpbnN0ZWFkLmApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGNvbW1vbiBpT1MgU2ltdWxhdG9yIHByZWZlcmVuY2VzIGZpbGUgd2l0aCBuZXcgdmFsdWVzLlxuICAgKiBJdCBpcyBuZWNlc3NhcnkgdG8gcmVzdGFydCB0aGUgY29ycmVzcG9uZGluZyBTaW11bGF0b3IgYmVmb3JlXG4gICAqIHRoZXNlIGNoYW5nZXMgYXJlIGFwcGxpZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7RGV2aWNlUHJlZmVyZW5jZXN9IGRldmljZVByZWZzIFt7fV0gLSBUaGUgbWFwcGluZywgd2hpY2ggcmVwcmVzZW50cyBuZXcgZGV2aWNlIHByZWZlcmVuY2UgdmFsdWVzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgdGhlIGdpdmVuIFNpbXVsYXRvci5cbiAgICogQHBhcmFtIHtDb21tb25QcmVmZXJlbmNlc30gY29tbW9uUHJlZnMgW3t9XSAtIFRoZSBtYXBwaW5nLCB3aGljaCByZXByZXNlbnRzIG5ldyBjb21tb24gcHJlZmVyZW5jZSB2YWx1ZXNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciBhbGwgU2ltdWxhdG9ycy5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgcHJlZmVyZW5jZXMgd2VyZSBzdWNjZXNzZnVsbHkgdXBkYXRlZC5cbiAgICovXG4gIGFzeW5jIHVwZGF0ZVByZWZlcmVuY2VzIChkZXZpY2VQcmVmcyA9IHt9LCBjb21tb25QcmVmcyA9IHt9KSB7XG4gICAgaWYgKCFfLmlzRW1wdHkoZGV2aWNlUHJlZnMpKSB7XG4gICAgICBsb2cuZGVidWcoYFNldHRpbmcgcHJlZmVyZW5jZXMgb2YgJHt0aGlzLnVkaWR9IFNpbXVsYXRvciB0byAke0pTT04uc3RyaW5naWZ5KGRldmljZVByZWZzKX1gKTtcbiAgICB9XG4gICAgaWYgKCFfLmlzRW1wdHkoY29tbW9uUHJlZnMpKSB7XG4gICAgICBsb2cuZGVidWcoYFNldHRpbmcgY29tbW9uIFNpbXVsYXRvciBwcmVmZXJlbmNlcyB0byAke0pTT04uc3RyaW5naWZ5KGNvbW1vblByZWZzKX1gKTtcbiAgICB9XG4gICAgY29uc3QgaG9tZUZvbGRlclBhdGggPSBwcm9jZXNzLmVudi5IT01FO1xuICAgIGlmICghaG9tZUZvbGRlclBhdGgpIHtcbiAgICAgIGxvZy53YXJuKGBDYW5ub3QgZ2V0IHRoZSBwYXRoIHRvIEhPTUUgZm9sZGVyIGZyb20gdGhlIHByb2Nlc3MgZW52aXJvbm1lbnQuIGAgK1xuICAgICAgICBgSWdub3JpbmcgU2ltdWxhdG9yIHByZWZlcmVuY2VzIHVwZGF0ZS5gKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy52ZXJpZnlEZXZpY2VQcmVmZXJlbmNlcyhkZXZpY2VQcmVmcyk7XG4gICAgY29uc3QgcGxpc3RQYXRoID0gcGF0aC5yZXNvbHZlKGhvbWVGb2xkZXJQYXRoLCAnTGlicmFyeScsICdQcmVmZXJlbmNlcycsICdjb20uYXBwbGUuaXBob25lc2ltdWxhdG9yLnBsaXN0Jyk7XG4gICAgaWYgKCFhd2FpdCBmcy5oYXNBY2Nlc3MocGxpc3RQYXRoKSkge1xuICAgICAgbG9nLndhcm4oYFNpbXVsYXRvciBwcmVmZXJlbmNlcyBmaWxlICcke3BsaXN0UGF0aH0nIGlzIG5vdCBhY2Nlc3NpYmxlLiBgICtcbiAgICAgICAgYElnbm9yaW5nIFNpbXVsYXRvciBwcmVmZXJlbmNlcyB1cGRhdGUuYCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxldCBuZXdQcmVmcyA9IHt9O1xuICAgIGlmICghXy5pc0VtcHR5KGRldmljZVByZWZzKSkge1xuICAgICAgbmV3UHJlZnMuRGV2aWNlUHJlZmVyZW5jZXMgPSB7W3RoaXMudWRpZC50b1VwcGVyQ2FzZSgpXTogZGV2aWNlUHJlZnN9O1xuICAgIH1cbiAgICBuZXdQcmVmcyA9IF8ubWVyZ2UobmV3UHJlZnMsIGNvbW1vblByZWZzKTtcbiAgICByZXR1cm4gYXdhaXQgcHJlZmVyZW5jZXNQbGlzdEd1YXJkLmFjcXVpcmUoU2ltdWxhdG9yWGNvZGU5Lm5hbWUsIGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRQbGlzdENvbnRlbnQgPSBhd2FpdCBwbGlzdC5wYXJzZVBsaXN0RmlsZShwbGlzdFBhdGgpO1xuICAgICAgICBhd2FpdCBwbGlzdC51cGRhdGVQbGlzdEZpbGUocGxpc3RQYXRoLCBfLm1lcmdlKGN1cnJlbnRQbGlzdENvbnRlbnQsIG5ld1ByZWZzKSwgdHJ1ZSk7XG4gICAgICAgIGxvZy5kZWJ1ZyhgVXBkYXRlZCAke3RoaXMudWRpZH0gU2ltdWxhdG9yIHByZWZlcmVuY2VzIGF0ICcke3BsaXN0UGF0aH0nIHdpdGggJHtKU09OLnN0cmluZ2lmeShuZXdQcmVmcyl9YCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBsb2cud2FybihgQ2Fubm90IHVwZGF0ZSAke3RoaXMudWRpZH0gU2ltdWxhdG9yIHByZWZlcmVuY2VzIGF0ICcke3BsaXN0UGF0aH0nLiBgICtcbiAgICAgICAgICAgICAgICAgYFRyeSB0byBkZWxldGUgdGhlIGZpbGUgbWFudWFsbHkgaW4gb3JkZXIgdG8gcmVzZXQgaXQuIE9yaWdpbmFsIGVycm9yOiAke2UubWVzc2FnZX1gKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IFNodXRkb3duT3B0aW9uc1xuICAgKiBAcHJvcGVydHkgez9udW1iZXJ8c3RyaW5nfSB0aW1lb3V0IFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHdhaXQgdW50aWxcbiAgICogU2ltdWxhdG9yIGlzIHNodXQgZG93biBjb21wbGV0ZWx5LiBObyB3YWl0IGhhcHBlbnMgaWYgdGhlIHRpbWVvdXQgdmFsdWUgaXMgbm90IHNldFxuICAgKi9cblxuICAvKipcbiAgICogU2h1dCBkb3duIHRoZSBjdXJyZW50IFNpbXVsYXRvci5cbiAgICogQG92ZXJyaWRlXG4gICAqXG4gICAqIEBwYXJhbSB7P1NodXRkb3duT3B0aW9uc30gb3B0c1xuICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgU2ltdWxhdG9yIGZhaWxzIHRvIHRyYW5zaXRpb24gaW50byBTaHV0ZG93biBzdGF0ZSBhZnRlclxuICAgKiB0aGUgZ2l2ZW4gdGltZW91dFxuICAgKi9cbiAgYXN5bmMgc2h1dGRvd24gKG9wdHMgPSB7fSkge1xuICAgIGlmIChhd2FpdCB0aGlzLmlzUnVubmluZygpKSB7XG4gICAgICBhd2FpdCByZXRyeUludGVydmFsKDUsIDUwMCwgdGhpcy5zaW1jdGwuc2h1dGRvd25EZXZpY2UuYmluZCh0aGlzLnNpbWN0bCkpO1xuICAgICAgY29uc3Qge1xuICAgICAgICB0aW1lb3V0LFxuICAgICAgfSA9IG9wdHM7XG4gICAgICBjb25zdCB3YWl0TXMgPSBwYXJzZUludCh0aW1lb3V0LCAxMCk7XG4gICAgICBpZiAod2FpdE1zID4gMCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGF3YWl0IHdhaXRGb3JDb25kaXRpb24oYXN5bmMgKCkgPT4gYXdhaXQgdGhpcy5pc1NodXRkb3duKCksIHtcbiAgICAgICAgICAgIHdhaXRNcyxcbiAgICAgICAgICAgIGludGVydmFsTXM6IDEwMCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTaW11bGF0b3IgaXMgbm90IGluICdTaHV0ZG93bicgc3RhdGUgYWZ0ZXIgJHt3YWl0TXN9bXNgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNldCB0aGUgY3VycmVudCBTaW11bGF0b3IgdG8gdGhlIGNsZWFuIHN0YXRlLlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGFzeW5jIGNsZWFuICgpIHtcbiAgICBsb2cuaW5mbyhgQ2xlYW5pbmcgc2ltdWxhdG9yICR7dGhpcy51ZGlkfWApO1xuICAgIGF3YWl0IHRoaXMuc2ltY3RsLmVyYXNlRGV2aWNlKDEwMDAwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdGRvY1xuICAgKiBAb3ZlcnJpZGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGFzeW5jIF9hY3RpdmF0ZVdpbmRvdyAoKSB7XG4gICAgbGV0IHNlbGZOYW1lO1xuICAgIGxldCBzZWxmU2RrO1xuICAgIGxldCBib290ZWREZXZpY2VzQ291bnQgPSAwO1xuICAgIGZvciAoY29uc3QgW3NkaywgZGV2aWNlQXJyXSBvZiBfLnRvUGFpcnMoYXdhaXQgdGhpcy5zaW1jdGwuZ2V0RGV2aWNlcygpKSkge1xuICAgICAgZm9yIChjb25zdCB7c3RhdGUsIHVkaWQsIG5hbWV9IG9mIGRldmljZUFycikge1xuICAgICAgICBpZiAoc3RhdGUgPT09ICdCb290ZWQnKSB7XG4gICAgICAgICAgYm9vdGVkRGV2aWNlc0NvdW50Kys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzZWxmTmFtZSAmJiB1ZGlkID09PSB0aGlzLnVkaWQpIHtcbiAgICAgICAgICBzZWxmU2RrID0gc2RrO1xuICAgICAgICAgIHNlbGZOYW1lID0gbmFtZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYm9vdGVkRGV2aWNlc0NvdW50IDwgMikge1xuICAgICAgcmV0dXJuIGF3YWl0IHN1cGVyLl9hY3RpdmF0ZVdpbmRvdygpO1xuICAgIH1cblxuICAgIC8vIFRoZXJlIGFyZSBwb3RlbnRpYWxseSBtb3JlIHRoYXQgb25lIFNpbXVsYXRvciB3aW5kb3dcbiAgICByZXR1cm4gYFxuICAgICAgdGVsbCBhcHBsaWNhdGlvbiBcIlN5c3RlbSBFdmVudHNcIlxuICAgICAgICB0ZWxsIHByb2Nlc3MgXCJTaW11bGF0b3JcIlxuICAgICAgICAgIHNldCBmcm9udG1vc3QgdG8gZmFsc2VcbiAgICAgICAgICBzZXQgZnJvbnRtb3N0IHRvIHRydWVcbiAgICAgICAgICBjbGljayAobWVudSBpdGVtIDEgd2hlcmUgKGl0cyBuYW1lIGNvbnRhaW5zIFwiJHtzZWxmTmFtZX0gXCIgYW5kIGl0cyBuYW1lIGNvbnRhaW5zIFwiJHtzZWxmU2RrfVwiKSkgb2YgbWVudSAxIG9mIG1lbnUgYmFyIGl0ZW0gXCJXaW5kb3dcIiBvZiBtZW51IGJhciAxXG4gICAgICAgIGVuZCB0ZWxsXG4gICAgICBlbmQgdGVsbFxuICAgIGA7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXRkb2NcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBhc3luYyBpc0Jpb21ldHJpY0Vucm9sbGVkICgpIHtcbiAgICBjb25zdCB7c3Rkb3V0fSA9IGF3YWl0IHRoaXMuc2ltY3RsLnNwYXduUHJvY2VzcyhbXG4gICAgICAnbm90aWZ5dXRpbCcsXG4gICAgICAnLWcnLCBFTlJPTExNRU5UX05PVElGSUNBVElPTl9SRUNFSVZFUlxuICAgIF0pO1xuICAgIGNvbnN0IG1hdGNoID0gKG5ldyBSZWdFeHAoYCR7Xy5lc2NhcGVSZWdFeHAoRU5ST0xMTUVOVF9OT1RJRklDQVRJT05fUkVDRUlWRVIpfVxcXFxzKyhbMDFdKWApKVxuICAgICAgLmV4ZWMoc3Rkb3V0KTtcbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBwYXJzZSBiaW9tZXRyaWMgZW5yb2xsbWVudCBzdGF0ZSBmcm9tICcke3N0ZG91dH0nYCk7XG4gICAgfVxuICAgIGxvZy5pbmZvKGBDdXJyZW50IGJpb21ldHJpYyBlbnJvbGxlZCBzdGF0ZSBmb3IgJHt0aGlzLnVkaWR9IFNpbXVsYXRvcjogJHttYXRjaFsxXX1gKTtcbiAgICByZXR1cm4gbWF0Y2hbMV0gPT09ICcxJztcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdGRvY1xuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGFzeW5jIGVucm9sbEJpb21ldHJpYyAoaXNFbmFibGVkID0gdHJ1ZSkge1xuICAgIGxvZy5kZWJ1ZyhgU2V0dGluZyBiaW9tZXRyaWMgZW5yb2xsZWQgc3RhdGUgZm9yICR7dGhpcy51ZGlkfSBTaW11bGF0b3IgdG8gJyR7aXNFbmFibGVkID8gJ2VuYWJsZWQnIDogJ2Rpc2FibGVkJ30nYCk7XG4gICAgYXdhaXQgdGhpcy5zaW1jdGwuc3Bhd25Qcm9jZXNzKFtcbiAgICAgICdub3RpZnl1dGlsJyxcbiAgICAgICctcycsIEVOUk9MTE1FTlRfTk9USUZJQ0FUSU9OX1JFQ0VJVkVSLCBpc0VuYWJsZWQgPyAnMScgOiAnMCdcbiAgICBdKTtcbiAgICBhd2FpdCB0aGlzLnNpbWN0bC5zcGF3blByb2Nlc3MoW1xuICAgICAgJ25vdGlmeXV0aWwnLFxuICAgICAgJy1wJywgRU5ST0xMTUVOVF9OT1RJRklDQVRJT05fUkVDRUlWRVJcbiAgICBdKTtcbiAgICBpZiAoYXdhaXQgdGhpcy5pc0Jpb21ldHJpY0Vucm9sbGVkKCkgIT09IGlzRW5hYmxlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3Qgc2V0IGJpb21ldHJpYyBlbnJvbGxlZCBzdGF0ZSBmb3IgJHt0aGlzLnVkaWR9IFNpbXVsYXRvciB0byAnJHtpc0VuYWJsZWQgPyAnZW5hYmxlZCcgOiAnZGlzYWJsZWQnfSdgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2VuZHMgYSBub3RpZmljYXRpb24gdG8gbWF0Y2gvbm90IG1hdGNoIHRoZSBwYXJ0aWN1bGFyIGJpb21ldHJpYy5cbiAgICogQG92ZXJyaWRlXG4gICAqXG4gICAqIEBwYXJhbSB7P2Jvb2xlYW59IHNob3VsZE1hdGNoIFt0cnVlXSAtIFNldCBpdCB0byB0cnVlIG9yIGZhbHNlIGluIG9yZGVyIHRvIGVtdWxhdGVcbiAgICogbWF0Y2hpbmcvbm90IG1hdGNoaW5nIHRoZSBjb3JyZXNwb25kaW5nIGJpb21ldHJpY1xuICAgKiBAcGFyYW0gez9zdHJpbmd9IGJpb21ldHJpY05hbWUgW3RvdWNoSWRdIC0gRWl0aGVyIHRvdWNoSWQgb3IgZmFjZUlkIChmYWNlSWQgaXMgb25seSBhdmFpbGFibGUgc2luY2UgaU9TIDExKVxuICAgKi9cbiAgYXN5bmMgc2VuZEJpb21ldHJpY01hdGNoIChzaG91bGRNYXRjaCA9IHRydWUsIGJpb21ldHJpY05hbWUgPSAndG91Y2hJZCcpIHtcbiAgICBjb25zdCBkb21haW5Db21wb25lbnQgPSB0b0Jpb21ldHJpY0RvbWFpbkNvbXBvbmVudChiaW9tZXRyaWNOYW1lKTtcbiAgICBjb25zdCBkb21haW4gPSBgY29tLmFwcGxlLkJpb21ldHJpY0tpdF9TaW0uJHtkb21haW5Db21wb25lbnR9LiR7c2hvdWxkTWF0Y2ggPyAnJyA6ICdubyd9bWF0Y2hgO1xuICAgIGF3YWl0IHRoaXMuc2ltY3RsLnNwYXduUHJvY2VzcyhbXG4gICAgICAnbm90aWZ5dXRpbCcsXG4gICAgICAnLXAnLCBkb21haW5cbiAgICBdKTtcbiAgICBsb2cuaW5mbyhgU2VudCBub3RpZmljYXRpb24gJHtkb21haW59IHRvICR7c2hvdWxkTWF0Y2ggPyAnbWF0Y2gnIDogJ25vdCBtYXRjaCd9ICR7YmlvbWV0cmljTmFtZX0gYmlvbWV0cmljIGAgK1xuICAgICAgYGZvciAke3RoaXMudWRpZH0gU2ltdWxhdG9yYCk7XG4gIH1cblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBhc3luYyBnZXRMYXVuY2hEYWVtb25zUm9vdCAoKSB7XG4gICAgY29uc3QgZGV2Um9vdCA9IGF3YWl0IGdldERldmVsb3BlclJvb3QoKTtcbiAgICByZXR1cm4gcGF0aC5yZXNvbHZlKGRldlJvb3QsXG4gICAgICAnUGxhdGZvcm1zL2lQaG9uZU9TLnBsYXRmb3JtL0RldmVsb3Blci9MaWJyYXJ5L0NvcmVTaW11bGF0b3IvUHJvZmlsZXMvUnVudGltZXMvaU9TLnNpbXJ1bnRpbWUvQ29udGVudHMvUmVzb3VyY2VzL1J1bnRpbWVSb290L1N5c3RlbS9MaWJyYXJ5L0xhdW5jaERhZW1vbnMnKTtcbiAgfVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFNpbXVsYXRvclhjb2RlOTtcbiJdLCJmaWxlIjoibGliL3NpbXVsYXRvci14Y29kZS05LmpzIiwic291cmNlUm9vdCI6Ii4uLy4uIn0=
