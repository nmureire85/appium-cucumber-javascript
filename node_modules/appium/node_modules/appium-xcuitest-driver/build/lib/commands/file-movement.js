"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getAvailableBundleIds = getAvailableBundleIds;
exports.parseContainerPath = parseContainerPath;
exports.default = exports.commands = void 0;

require("source-map-support/register");

var _lodash = _interopRequireDefault(require("lodash"));

var _appiumSupport = require("appium-support");

var _path = _interopRequireDefault(require("path"));

var _appiumIosDriver = require("appium-ios-driver");

var _logger = _interopRequireDefault(require("../logger"));

var _teen_process = require("teen_process");

var _bluebird = _interopRequireDefault(require("bluebird"));

var _appiumIosDevice = require("appium-ios-device");

const CONTAINER_PATH_MARKER = '@';
const CONTAINER_PATH_PATTERN = new RegExp(`^${CONTAINER_PATH_MARKER}([^/]+)/(.*)`);
const CONTAINER_TYPE_SEPARATOR = ':';
const IFUSE_CONTAINER_DOCUMENTS = 'documents';
const CONTAINER_DOCUMENTS_PATH = 'Documents';
const IO_TIMEOUT = 60000;
const OBJECT_NOT_FOUND_ERROR_MESSAGE = 'OBJECT_NOT_FOUND';
const MAX_PULL_CHUNK_SIZE = 5;
let commands = _appiumIosDriver.iosCommands.file;
exports.commands = commands;

function verifyIsSubPath(originalPath, root) {
  const normalizedRoot = _path.default.normalize(root);

  const normalizedPath = _path.default.normalize(_path.default.dirname(originalPath));

  if (normalizedRoot !== originalPath && !normalizedPath.startsWith(normalizedRoot)) {
    _logger.default.errorAndThrow(`'${normalizedPath}' is expected to be a subpath of '${normalizedRoot}'`);
  }
}

async function createAfcClient(udid, bundleId, containerType) {
  if (!bundleId) {
    return await _appiumIosDevice.services.startAfcService(udid);
  }

  const service = await _appiumIosDevice.services.startHouseArrestService(udid);

  if (isDocuments(containerType)) {
    return await service.vendDocuments(bundleId);
  } else {
    return await service.vendContainer(bundleId);
  }
}

function isDocuments(containerType) {
  return _lodash.default.toLower(containerType) === IFUSE_CONTAINER_DOCUMENTS;
}

async function mkdirpDevice(service, dir) {
  if (dir === '.' || dir === '/') {
    return;
  }

  try {
    await service.listDirectory(dir);
    return;
  } catch (e) {
    await mkdirpDevice(service, _path.default.dirname(dir));
  }

  await service.createDirectory(dir);
}

async function createService(udid, remotePath) {
  if (CONTAINER_PATH_PATTERN.test(remotePath)) {
    const {
      bundleId,
      pathInContainer,
      containerType
    } = await parseContainerPath(remotePath);
    const service = await createAfcClient(udid, bundleId, containerType);
    const relativePath = isDocuments(containerType) ? _path.default.join(CONTAINER_DOCUMENTS_PATH, pathInContainer) : pathInContainer;
    return {
      service,
      relativePath
    };
  } else {
    const service = await createAfcClient(udid);
    const relativePath = remotePath;
    return {
      service,
      relativePath
    };
  }
}

async function pullFileFromRealDevice(service, relativePath) {
  const stream = await service.createReadStream(relativePath, {
    autoDestroy: true
  });
  const pullPromise = new _bluebird.default((resolve, reject) => {
    stream.on('close', resolve);
    stream.on('error', reject);
  });
  const buffers = [];
  stream.on('data', data => buffers.push(data));

  try {
    await pullPromise.timeout(IO_TIMEOUT);
  } catch (e) {
    throw new Error(`Couldn't pull the file '${relativePath}' ` + `within the given timeout ${IO_TIMEOUT}ms. Original error: ${e.message}`);
  }

  return Buffer.concat(buffers).toString('base64');
}

async function pullFolderFromRealDevice(service, relativePath) {
  const tmpFolder = await _appiumSupport.tempDir.openDir();

  try {
    const folderPath = _path.default.join(tmpFolder, relativePath);

    await (0, _appiumSupport.mkdirp)(folderPath);
    const pullPromises = [];

    const waitForPullChunks = async () => {
      if (_lodash.default.isEmpty(pullPromises)) {
        return;
      }

      try {
        await _bluebird.default.all(pullPromises).timeout(IO_TIMEOUT);
      } catch (e) {
        throw new Error(`Couldn't pull all items in the folder '${relativePath}' ` + `within the given timeout ${IO_TIMEOUT}ms. Original error: ${e.message}`);
      }
    };

    await service.walkDir(relativePath, true, async (itemPath, isDir) => {
      const pathOnServer = _path.default.join(tmpFolder, itemPath);

      if (isDir) {
        await _appiumSupport.fs.mkdir(pathOnServer);
        return;
      }

      const readStream = await service.createReadStream(itemPath, {
        autoDestroy: true
      });

      const writeStream = _appiumSupport.fs.createWriteStream(pathOnServer, {
        autoClose: true
      });

      pullPromises.push(new _bluebird.default((resolve, reject) => {
        writeStream.on('close', resolve);

        const onStreamingError = e => {
          readStream.unpipe(writeStream);
          reject(e);
        };

        writeStream.on('error', onStreamingError);
        readStream.on('error', onStreamingError);
      }));
      readStream.pipe(writeStream);

      if (pullPromises.length % MAX_PULL_CHUNK_SIZE === 0) {
        await waitForPullChunks();
      }
    });
    await waitForPullChunks();
    return (await _appiumSupport.zip.toInMemoryZip(folderPath, {
      encodeToBase64: true
    })).toString();
  } finally {
    await _appiumSupport.fs.rimraf(tmpFolder);
  }
}

async function parseContainerPath(remotePath, containerRootSupplier) {
  const match = CONTAINER_PATH_PATTERN.exec(remotePath);

  if (!match) {
    _logger.default.errorAndThrow(`It is expected that package identifier ` + `starts with '${CONTAINER_PATH_MARKER}' and is separated from the ` + `relative path with a single slash. '${remotePath}' is given instead`);
  }

  let [, bundleId, relativePath] = match;
  let containerType = null;
  const typeSeparatorPos = bundleId.indexOf(CONTAINER_TYPE_SEPARATOR);

  if (typeSeparatorPos > 0 && typeSeparatorPos < bundleId.length - 1) {
    containerType = bundleId.substring(typeSeparatorPos + 1);

    _logger.default.debug(`Parsed container type: ${containerType}`);

    bundleId = bundleId.substring(0, typeSeparatorPos);
  }

  if (_lodash.default.isNil(containerRootSupplier)) {
    const pathInContainer = relativePath;
    return {
      bundleId,
      pathInContainer,
      containerType
    };
  }

  const containerRoot = _lodash.default.isFunction(containerRootSupplier) ? await containerRootSupplier(bundleId, containerType) : containerRootSupplier;

  const pathInContainer = _path.default.posix.resolve(containerRoot, relativePath);

  verifyIsSubPath(pathInContainer, containerRoot);
  return {
    bundleId,
    pathInContainer,
    containerType
  };
}

async function pushFileToSimulator(device, remotePath, base64Data) {
  const buffer = Buffer.from(base64Data, 'base64');

  if (CONTAINER_PATH_PATTERN.test(remotePath)) {
    const {
      bundleId,
      pathInContainer: dstPath
    } = await parseContainerPath(remotePath, async (appBundle, containerType) => await device.simctl.getAppContainer(appBundle, containerType));

    _logger.default.info(`Parsed bundle identifier '${bundleId}' from '${remotePath}'. ` + `Will put the data into '${dstPath}'`);

    if (!(await _appiumSupport.fs.exists(_path.default.dirname(dstPath)))) {
      _logger.default.debug(`The destination folder '${_path.default.dirname(dstPath)}' does not exist. Creating...`);

      await (0, _appiumSupport.mkdirp)(_path.default.dirname(dstPath));
    }

    await _appiumSupport.fs.writeFile(dstPath, buffer);
    return;
  }

  const dstFolder = await _appiumSupport.tempDir.openDir();

  const dstPath = _path.default.resolve(dstFolder, _path.default.basename(remotePath));

  try {
    await _appiumSupport.fs.writeFile(dstPath, buffer);
    await device.simctl.addMedia(dstPath);
  } finally {
    await _appiumSupport.fs.rimraf(dstFolder);
  }
}

async function pushFileToRealDevice(device, remotePath, base64Data) {
  const {
    service,
    relativePath
  } = await createService(device.udid, remotePath);

  try {
    await mkdirpDevice(service, _path.default.dirname(relativePath));
    const stream = await service.createWriteStream(relativePath, {
      autoDestroy: true
    });
    let pushError = null;
    const pushPromise = new _bluebird.default((resolve, reject) => {
      stream.on('error', e => {
        pushError = e;
      });
      stream.on('close', () => {
        if (pushError) {
          reject(pushError);
        } else {
          resolve();
        }
      });
    });
    stream.write(Buffer.from(base64Data, 'base64'));
    stream.end();

    try {
      await pushPromise.timeout(IO_TIMEOUT);
    } catch (e) {
      throw new Error(`Could not push the file within the given timeout ${IO_TIMEOUT}ms. ` + `Original error: ${e.message}`);
    }
  } finally {
    service.close();
  }
}

async function pullFromSimulator(device, remotePath, isFile) {
  let pathOnServer;

  if (CONTAINER_PATH_PATTERN.test(remotePath)) {
    const {
      bundleId,
      pathInContainer: dstPath
    } = await parseContainerPath(remotePath, async (appBundle, containerType) => await device.simctl.getAppContainer(appBundle, containerType));

    _logger.default.info(`Parsed bundle identifier '${bundleId}' from '${remotePath}'. ` + `Will get the data from '${dstPath}'`);

    pathOnServer = dstPath;
  } else {
    const simRoot = device.getDir();
    pathOnServer = _path.default.posix.join(simRoot, remotePath);
    verifyIsSubPath(pathOnServer, simRoot);

    _logger.default.info(`Got the full item path: ${pathOnServer}`);
  }

  if (!(await _appiumSupport.fs.exists(pathOnServer))) {
    _logger.default.errorAndThrow(`The remote ${isFile ? 'file' : 'folder'} at '${pathOnServer}' does not exist`);
  }

  const buffer = isFile ? await _appiumSupport.util.toInMemoryBase64(pathOnServer) : await _appiumSupport.zip.toInMemoryZip(pathOnServer, {
    encodeToBase64: true
  });
  return buffer.toString();
}

async function pullFromRealDevice(device, remotePath, isFile) {
  const {
    service,
    relativePath
  } = await createService(device.udid, remotePath);

  try {
    const fileInfo = await service.getFileInfo(relativePath);

    if (isFile && fileInfo.isDirectory()) {
      throw new Error(`The requested path is not a file. Path: '${remotePath}'`);
    }

    if (!isFile && !fileInfo.isDirectory()) {
      throw new Error(`The requested path is not a folder. Path: '${remotePath}'`);
    }

    if (fileInfo.isFile()) {
      return await pullFileFromRealDevice(service, relativePath);
    } else {
      return await pullFolderFromRealDevice(service, relativePath);
    }
  } catch (e) {
    if (e.message.includes(OBJECT_NOT_FOUND_ERROR_MESSAGE)) {
      throw new Error(`Path '${remotePath}' does not exist on the device`);
    }

    throw e;
  } finally {
    service.close();
  }
}

async function deleteFromSimulator(device, remotePath) {
  let pathOnServer;

  if (CONTAINER_PATH_PATTERN.test(remotePath)) {
    const {
      bundleId,
      pathInContainer: dstPath
    } = await parseContainerPath(remotePath, async (appBundle, containerType) => await device.simctl.getAppContainer(appBundle, containerType));

    _logger.default.info(`Parsed bundle identifier '${bundleId}' from '${remotePath}'. ` + `'${dstPath}' will be deleted`);

    pathOnServer = dstPath;
  } else {
    const simRoot = device.getDir();
    pathOnServer = _path.default.posix.join(simRoot, remotePath);
    verifyIsSubPath(pathOnServer, simRoot);

    _logger.default.info(`Got the full path: ${pathOnServer}`);
  }

  if (!(await _appiumSupport.fs.exists(pathOnServer))) {
    _logger.default.errorAndThrow(`The remote path at '${pathOnServer}' does not exist`);
  }

  await _appiumSupport.fs.rimraf(pathOnServer);
}

async function deleteFromRealDevice(device, remotePath) {
  const {
    service,
    relativePath
  } = await createService(device.udid, remotePath);

  try {
    await service.deleteDirectory(relativePath);
  } catch (e) {
    if (e.message.includes(OBJECT_NOT_FOUND_ERROR_MESSAGE)) {
      throw new Error(`Path '${remotePath}' does not exist on the device`);
    }

    throw e;
  } finally {
    service.close();
  }
}

async function getAvailableBundleIds(udid) {
  const service = await _appiumIosDevice.services.startInstallationProxyService(udid);

  try {
    const applications = await service.listApplications({
      applicationType: 'User'
    });
    const bundleIds = [];

    for (const [key, value] of Object.entries(applications)) {
      if (!value.UIFileSharingEnabled) {
        continue;
      }

      bundleIds.push(key);
    }

    return bundleIds;
  } finally {
    service.close();
  }
}

commands.pushFile = async function pushFile(remotePath, base64Data) {
  if (remotePath.endsWith('/')) {
    _logger.default.errorAndThrow(`It is expected that remote path points to a file and not to a folder. ` + `'${remotePath}' is given instead`);
  }

  if (_lodash.default.isArray(base64Data)) {
    base64Data = Buffer.from(base64Data).toString('utf8');
  }

  return this.isSimulator() ? await pushFileToSimulator(this.opts.device, remotePath, base64Data) : await pushFileToRealDevice(this.opts.device, remotePath, base64Data);
};

commands.pullFile = async function pullFile(remotePath) {
  if (remotePath.endsWith('/')) {
    _logger.default.errorAndThrow(`It is expected that remote path points to a file and not to a folder. ` + `'${remotePath}' is given instead`);
  }

  return this.isSimulator() ? await pullFromSimulator(this.opts.device, remotePath, true) : await pullFromRealDevice(this.opts.device, remotePath, true);
};

async function deleteFileOrFolder(device, remotePath, isSimulator) {
  return isSimulator ? await deleteFromSimulator(device, remotePath) : await deleteFromRealDevice(device, remotePath);
}

commands.mobileDeleteFolder = async function mobileDeleteFolder(opts = {}) {
  let {
    remotePath
  } = opts;

  if (!remotePath.endsWith('/')) {
    remotePath = `${remotePath}/`;
  }

  return await deleteFileOrFolder(this.opts.device, remotePath, this.isSimulator());
};

commands.mobileDeleteFile = async function mobileDeleteFile(opts = {}) {
  const {
    remotePath
  } = opts;

  if (remotePath.endsWith('/')) {
    _logger.default.errorAndThrow(`It is expected that remote path points to a file and not to a folder. ` + `'${remotePath}' is given instead`);
  }

  return await deleteFileOrFolder(this.opts.device, remotePath, this.isSimulator());
};

commands.getSimFileFullPath = async function getSimFileFullPath(remotePath) {
  let basePath = this.opts.device.getDir();
  let appName = null;

  if (this.opts.app) {
    let appNameRegex = new RegExp(`\\${_path.default.sep}([\\w-]+\\.app)`);
    let appNameMatches = appNameRegex.exec(this.opts.app);

    if (appNameMatches) {
      appName = appNameMatches[1];
    }
  }

  if (_appiumSupport.system.isWindows()) {
    if (remotePath.indexof('://') === 1) {
      remotePath = remotePath.slice(4);
    }
  } else {
    if (remotePath.indexOf('/') === 0) {
      remotePath = remotePath.slice(1);
    }
  }

  if (remotePath.startsWith(appName)) {
    let findPath = basePath;

    if (!this.opts.platformVersion || _appiumSupport.util.compareVersions(this.opts.platformVersion, '>=', '8.0')) {
      findPath = _path.default.resolve(basePath, 'Containers', 'Bundle');
    }

    findPath = findPath.replace(/\s/g, '\\ ');
    let {
      stdout
    } = await (0, _teen_process.exec)('find', [findPath, '-name', appName]);
    let appRoot = stdout.replace(/\n$/, '');
    let subPath = remotePath.substring(appName.length + 1);

    let fullPath = _path.default.resolve(appRoot, subPath);

    _logger.default.debug(`Finding app-relative file: '${fullPath}'`);

    return fullPath;
  }

  let fullPath = _path.default.resolve(basePath, remotePath);

  _logger.default.debug(`Finding sim-relative file: ${fullPath}`);

  return fullPath;
};

commands.pullFolder = async function pullFolder(remotePath) {
  if (!remotePath.endsWith('/')) {
    remotePath = `${remotePath}/`;
  }

  return this.isSimulator() ? await pullFromSimulator(this.opts.device, remotePath, false) : await pullFromRealDevice(this.opts.device, remotePath, false);
};

var _default = commands;
exports.default = _default;require('source-map-support').install();


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9jb21tYW5kcy9maWxlLW1vdmVtZW50LmpzIl0sIm5hbWVzIjpbIkNPTlRBSU5FUl9QQVRIX01BUktFUiIsIkNPTlRBSU5FUl9QQVRIX1BBVFRFUk4iLCJSZWdFeHAiLCJDT05UQUlORVJfVFlQRV9TRVBBUkFUT1IiLCJJRlVTRV9DT05UQUlORVJfRE9DVU1FTlRTIiwiQ09OVEFJTkVSX0RPQ1VNRU5UU19QQVRIIiwiSU9fVElNRU9VVCIsIk9CSkVDVF9OT1RfRk9VTkRfRVJST1JfTUVTU0FHRSIsIk1BWF9QVUxMX0NIVU5LX1NJWkUiLCJjb21tYW5kcyIsImlvc0NvbW1hbmRzIiwiZmlsZSIsInZlcmlmeUlzU3ViUGF0aCIsIm9yaWdpbmFsUGF0aCIsInJvb3QiLCJub3JtYWxpemVkUm9vdCIsInBhdGgiLCJub3JtYWxpemUiLCJub3JtYWxpemVkUGF0aCIsImRpcm5hbWUiLCJzdGFydHNXaXRoIiwibG9nIiwiZXJyb3JBbmRUaHJvdyIsImNyZWF0ZUFmY0NsaWVudCIsInVkaWQiLCJidW5kbGVJZCIsImNvbnRhaW5lclR5cGUiLCJzZXJ2aWNlcyIsInN0YXJ0QWZjU2VydmljZSIsInNlcnZpY2UiLCJzdGFydEhvdXNlQXJyZXN0U2VydmljZSIsImlzRG9jdW1lbnRzIiwidmVuZERvY3VtZW50cyIsInZlbmRDb250YWluZXIiLCJfIiwidG9Mb3dlciIsIm1rZGlycERldmljZSIsImRpciIsImxpc3REaXJlY3RvcnkiLCJlIiwiY3JlYXRlRGlyZWN0b3J5IiwiY3JlYXRlU2VydmljZSIsInJlbW90ZVBhdGgiLCJ0ZXN0IiwicGF0aEluQ29udGFpbmVyIiwicGFyc2VDb250YWluZXJQYXRoIiwicmVsYXRpdmVQYXRoIiwiam9pbiIsInB1bGxGaWxlRnJvbVJlYWxEZXZpY2UiLCJzdHJlYW0iLCJjcmVhdGVSZWFkU3RyZWFtIiwiYXV0b0Rlc3Ryb3kiLCJwdWxsUHJvbWlzZSIsIkIiLCJyZXNvbHZlIiwicmVqZWN0Iiwib24iLCJidWZmZXJzIiwiZGF0YSIsInB1c2giLCJ0aW1lb3V0IiwiRXJyb3IiLCJtZXNzYWdlIiwiQnVmZmVyIiwiY29uY2F0IiwidG9TdHJpbmciLCJwdWxsRm9sZGVyRnJvbVJlYWxEZXZpY2UiLCJ0bXBGb2xkZXIiLCJ0ZW1wRGlyIiwib3BlbkRpciIsImZvbGRlclBhdGgiLCJwdWxsUHJvbWlzZXMiLCJ3YWl0Rm9yUHVsbENodW5rcyIsImlzRW1wdHkiLCJhbGwiLCJ3YWxrRGlyIiwiaXRlbVBhdGgiLCJpc0RpciIsInBhdGhPblNlcnZlciIsImZzIiwibWtkaXIiLCJyZWFkU3RyZWFtIiwid3JpdGVTdHJlYW0iLCJjcmVhdGVXcml0ZVN0cmVhbSIsImF1dG9DbG9zZSIsIm9uU3RyZWFtaW5nRXJyb3IiLCJ1bnBpcGUiLCJwaXBlIiwibGVuZ3RoIiwiemlwIiwidG9Jbk1lbW9yeVppcCIsImVuY29kZVRvQmFzZTY0IiwicmltcmFmIiwiY29udGFpbmVyUm9vdFN1cHBsaWVyIiwibWF0Y2giLCJleGVjIiwidHlwZVNlcGFyYXRvclBvcyIsImluZGV4T2YiLCJzdWJzdHJpbmciLCJkZWJ1ZyIsImlzTmlsIiwiY29udGFpbmVyUm9vdCIsImlzRnVuY3Rpb24iLCJwb3NpeCIsInB1c2hGaWxlVG9TaW11bGF0b3IiLCJkZXZpY2UiLCJiYXNlNjREYXRhIiwiYnVmZmVyIiwiZnJvbSIsImRzdFBhdGgiLCJhcHBCdW5kbGUiLCJzaW1jdGwiLCJnZXRBcHBDb250YWluZXIiLCJpbmZvIiwiZXhpc3RzIiwid3JpdGVGaWxlIiwiZHN0Rm9sZGVyIiwiYmFzZW5hbWUiLCJhZGRNZWRpYSIsInB1c2hGaWxlVG9SZWFsRGV2aWNlIiwicHVzaEVycm9yIiwicHVzaFByb21pc2UiLCJ3cml0ZSIsImVuZCIsImNsb3NlIiwicHVsbEZyb21TaW11bGF0b3IiLCJpc0ZpbGUiLCJzaW1Sb290IiwiZ2V0RGlyIiwidXRpbCIsInRvSW5NZW1vcnlCYXNlNjQiLCJwdWxsRnJvbVJlYWxEZXZpY2UiLCJmaWxlSW5mbyIsImdldEZpbGVJbmZvIiwiaXNEaXJlY3RvcnkiLCJpbmNsdWRlcyIsImRlbGV0ZUZyb21TaW11bGF0b3IiLCJkZWxldGVGcm9tUmVhbERldmljZSIsImRlbGV0ZURpcmVjdG9yeSIsImdldEF2YWlsYWJsZUJ1bmRsZUlkcyIsInN0YXJ0SW5zdGFsbGF0aW9uUHJveHlTZXJ2aWNlIiwiYXBwbGljYXRpb25zIiwibGlzdEFwcGxpY2F0aW9ucyIsImFwcGxpY2F0aW9uVHlwZSIsImJ1bmRsZUlkcyIsImtleSIsInZhbHVlIiwiT2JqZWN0IiwiZW50cmllcyIsIlVJRmlsZVNoYXJpbmdFbmFibGVkIiwicHVzaEZpbGUiLCJlbmRzV2l0aCIsImlzQXJyYXkiLCJpc1NpbXVsYXRvciIsIm9wdHMiLCJwdWxsRmlsZSIsImRlbGV0ZUZpbGVPckZvbGRlciIsIm1vYmlsZURlbGV0ZUZvbGRlciIsIm1vYmlsZURlbGV0ZUZpbGUiLCJnZXRTaW1GaWxlRnVsbFBhdGgiLCJiYXNlUGF0aCIsImFwcE5hbWUiLCJhcHAiLCJhcHBOYW1lUmVnZXgiLCJzZXAiLCJhcHBOYW1lTWF0Y2hlcyIsInN5c3RlbSIsImlzV2luZG93cyIsImluZGV4b2YiLCJzbGljZSIsImZpbmRQYXRoIiwicGxhdGZvcm1WZXJzaW9uIiwiY29tcGFyZVZlcnNpb25zIiwicmVwbGFjZSIsInN0ZG91dCIsImFwcFJvb3QiLCJzdWJQYXRoIiwiZnVsbFBhdGgiLCJwdWxsRm9sZGVyIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBRUEsTUFBTUEscUJBQXFCLEdBQUcsR0FBOUI7QUFFQSxNQUFNQyxzQkFBc0IsR0FBRyxJQUFJQyxNQUFKLENBQVksSUFBR0YscUJBQXNCLGNBQXJDLENBQS9CO0FBQ0EsTUFBTUcsd0JBQXdCLEdBQUcsR0FBakM7QUFDQSxNQUFNQyx5QkFBeUIsR0FBRyxXQUFsQztBQUNBLE1BQU1DLHdCQUF3QixHQUFHLFdBQWpDO0FBQ0EsTUFBTUMsVUFBVSxHQUFHLEtBQW5CO0FB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R0FBbEQ7O0FBQ0EsV0FBT0EsUUFBUDtBQUNEOztBQUVELE1BQUlBLFFBQVEsR0FBR2pLLGNBQUtzQyxPQUFMLENBQWEwRyxRQUFiLEVBQXVCdEgsVUFBdkIsQ0FBZjs7QUFDQXJCLGtCQUFJOEUsS0FBSixDQUFXLDhCQUE2QjhFLFFBQVMsRUFBakQ7O0FBQ0EsU0FBT0EsUUFBUDtBQUNELENBekNEOztBQTJDQXhLLFFBQVEsQ0FBQ3lLLFVBQVQsR0FBc0IsZUFBZUEsVUFBZixDQUEyQnhJLFVBQTNCLEVBQXVDO0FBQzNELE1BQUksQ0FBQ0EsVUFBVSxDQUFDNkcsUUFBWCxDQUFvQixHQUFwQixDQUFMLEVBQStCO0FBQzdCN0csSUFBQUEsVUFBVSxHQUFJLEdBQUVBLFVBQVcsR0FBM0I7QUFDRDs7QUFDRCxTQUFPLEtBQUsrRyxXQUFMLEtBQ0gsTUFBTTVCLGlCQUFpQixDQUFDLEtBQUs2QixJQUFMLENBQVVqRCxNQUFYLEVBQW1CL0QsVUFBbkIsRUFBK0IsS0FBL0IsQ0FEcEIsR0FFSCxNQUFNeUYsa0JBQWtCLENBQUMsS0FBS3VCLElBQUwsQ0FBVWpELE1BQVgsRUFBbUIvRCxVQUFuQixFQUErQixLQUEvQixDQUY1QjtBQUdELENBUEQ7O2VBV2VqQyxRIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IHN5c3RlbSwgZnMsIHRlbXBEaXIsIG1rZGlycCwgemlwLCB1dGlsIH0gZnJvbSAnYXBwaXVtLXN1cHBvcnQnO1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgeyBpb3NDb21tYW5kcyB9IGZyb20gJ2FwcGl1bS1pb3MtZHJpdmVyJztcbmltcG9ydCBsb2cgZnJvbSAnLi4vbG9nZ2VyJztcbmltcG9ydCB7IGV4ZWMgfSBmcm9tICd0ZWVuX3Byb2Nlc3MnO1xuaW1wb3J0IEIgZnJvbSAnYmx1ZWJpcmQnO1xuaW1wb3J0IHsgc2VydmljZXMgfSBmcm9tICdhcHBpdW0taW9zLWRldmljZSc7XG5cbmNvbnN0IENPTlRBSU5FUl9QQVRIX01BUktFUiA9ICdAJztcbi8vIGh0dHBzOi8vcmVnZXgxMDEuY29tL3IvUExkQjBHLzJcbmNvbnN0IENPTlRBSU5FUl9QQVRIX1BBVFRFUk4gPSBuZXcgUmVnRXhwKGBeJHtDT05UQUlORVJfUEFUSF9NQVJLRVJ9KFteL10rKS8oLiopYCk7XG5jb25zdCBDT05UQUlORVJfVFlQRV9TRVBBUkFUT1IgPSAnOic7XG5jb25zdCBJRlVTRV9DT05UQUlORVJfRE9DVU1FTlRTID0gJ2RvY3VtZW50cyc7XG5jb25zdCBDT05UQUlORVJfRE9DVU1FTlRTX1BBVEggPSAnRG9jdW1lbnRzJztcbmNvbnN0IElPX1RJTUVPVVQgPSA2MDAwMDtcbmNvbnN0IE9CSkVDVF9OT1RfRk9VTkRfRVJST1JfTUVTU0FHRSA9ICdPQkpFQ1RfTk9UX0ZPVU5EJztcbmNvbnN0IE1BWF9QVUxMX0NIVU5LX1NJWkUgPSA1O1xuXG5sZXQgY29tbWFuZHMgPSBpb3NDb21tYW5kcy5maWxlO1xuXG5mdW5jdGlvbiB2ZXJpZnlJc1N1YlBhdGggKG9yaWdpbmFsUGF0aCwgcm9vdCkge1xuICBjb25zdCBub3JtYWxpemVkUm9vdCA9IHBhdGgubm9ybWFsaXplKHJvb3QpO1xuICBjb25zdCBub3JtYWxpemVkUGF0aCA9IHBhdGgubm9ybWFsaXplKHBhdGguZGlybmFtZShvcmlnaW5hbFBhdGgpKTtcbiAgLy8gSWYgb3JpZ2luYWxQYXRoIGlzIHJvb3QsIGAvYCwgb3JpZ2luYWxQYXRoIHNob3VsZCBlcXVhbCB0byBub3JtYWxpemVkUm9vdFxuICBpZiAobm9ybWFsaXplZFJvb3QgIT09IG9yaWdpbmFsUGF0aCAmJiAhbm9ybWFsaXplZFBhdGguc3RhcnRzV2l0aChub3JtYWxpemVkUm9vdCkpIHtcbiAgICBsb2cuZXJyb3JBbmRUaHJvdyhgJyR7bm9ybWFsaXplZFBhdGh9JyBpcyBleHBlY3RlZCB0byBiZSBhIHN1YnBhdGggb2YgJyR7bm9ybWFsaXplZFJvb3R9J2ApO1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUFmY0NsaWVudCAodWRpZCwgYnVuZGxlSWQsIGNvbnRhaW5lclR5cGUpIHtcbiAgaWYgKCFidW5kbGVJZCkge1xuICAgIHJldHVybiBhd2FpdCBzZXJ2aWNlcy5zdGFydEFmY1NlcnZpY2UodWRpZCk7XG4gIH1cbiAgY29uc3Qgc2VydmljZSA9IGF3YWl0IHNlcnZpY2VzLnN0YXJ0SG91c2VBcnJlc3RTZXJ2aWNlKHVkaWQpO1xuICBpZiAoaXNEb2N1bWVudHMoY29udGFpbmVyVHlwZSkpIHtcbiAgICByZXR1cm4gYXdhaXQgc2VydmljZS52ZW5kRG9jdW1lbnRzKGJ1bmRsZUlkKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYXdhaXQgc2VydmljZS52ZW5kQ29udGFpbmVyKGJ1bmRsZUlkKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0RvY3VtZW50cyAoY29udGFpbmVyVHlwZSkge1xuICByZXR1cm4gXy50b0xvd2VyKGNvbnRhaW5lclR5cGUpID09PSBJRlVTRV9DT05UQUlORVJfRE9DVU1FTlRTO1xufVxuXG5hc3luYyBmdW5jdGlvbiBta2RpcnBEZXZpY2UgKHNlcnZpY2UsIGRpcikge1xuICBpZiAoZGlyID09PSAnLicgfHwgZGlyID09PSAnLycpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdHJ5IHtcbiAgICBhd2FpdCBzZXJ2aWNlLmxpc3REaXJlY3RvcnkoZGlyKTtcbiAgICByZXR1cm47XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBUaGlzIG1lYW5zIHRoYXQgdGhlIGRpcmVjdG9yeSBpcyBtaXNzaW5nIGFuZCB3ZSBnb3QgYW4gb2JqZWN0IG5vdCBmb3VuZCBlcnJvci4gVGhlcmVmb3JlLCB3ZSBhcmUgZ29pbmcgdG8gdGhlIHBhcmVudFxuICAgIGF3YWl0IG1rZGlycERldmljZShzZXJ2aWNlLCBwYXRoLmRpcm5hbWUoZGlyKSk7XG4gIH1cbiAgYXdhaXQgc2VydmljZS5jcmVhdGVEaXJlY3RvcnkoZGlyKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gY3JlYXRlU2VydmljZSAodWRpZCwgcmVtb3RlUGF0aCkge1xuICBpZiAoQ09OVEFJTkVSX1BBVEhfUEFUVEVSTi50ZXN0KHJlbW90ZVBhdGgpKSB7XG4gICAgY29uc3Qge2J1bmRsZUlkLCBwYXRoSW5Db250YWluZXIsIGNvbnRhaW5lclR5cGV9ID0gYXdhaXQgcGFyc2VDb250YWluZXJQYXRoKHJlbW90ZVBhdGgpO1xuICAgIGNvbnN0IHNlcnZpY2UgPSBhd2FpdCBjcmVhdGVBZmNDbGllbnQodWRpZCwgYnVuZGxlSWQsIGNvbnRhaW5lclR5cGUpO1xuICAgIGNvbnN0IHJlbGF0aXZlUGF0aCA9IGlzRG9jdW1lbnRzKGNvbnRhaW5lclR5cGUpID8gcGF0aC5qb2luKENPTlRBSU5FUl9ET0NVTUVOVFNfUEFUSCwgcGF0aEluQ29udGFpbmVyKSA6IHBhdGhJbkNvbnRhaW5lcjtcbiAgICByZXR1cm4ge3NlcnZpY2UsIHJlbGF0aXZlUGF0aH07XG4gIH0gZWxzZSB7XG4gICAgY29uc3Qgc2VydmljZSA9IGF3YWl0IGNyZWF0ZUFmY0NsaWVudCh1ZGlkKTtcbiAgICBjb25zdCByZWxhdGl2ZVBhdGggPSByZW1vdGVQYXRoO1xuICAgIHJldHVybiB7c2VydmljZSwgcmVsYXRpdmVQYXRofTtcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBwdWxsRmlsZUZyb21SZWFsRGV2aWNlIChzZXJ2aWNlLCByZWxhdGl2ZVBhdGgpIHtcbiAgY29uc3Qgc3RyZWFtID0gYXdhaXQgc2VydmljZS5jcmVhdGVSZWFkU3RyZWFtKHJlbGF0aXZlUGF0aCwgeyBhdXRvRGVzdHJveTogdHJ1ZSB9KTtcbiAgY29uc3QgcHVsbFByb21pc2UgPSBuZXcgQigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgc3RyZWFtLm9uKCdjbG9zZScsIHJlc29sdmUpO1xuICAgIHN0cmVhbS5vbignZXJyb3InLCByZWplY3QpO1xuICB9KTtcbiAgY29uc3QgYnVmZmVycyA9IFtdO1xuICBzdHJlYW0ub24oJ2RhdGEnLCAoZGF0YSkgPT4gYnVmZmVycy5wdXNoKGRhdGEpKTtcbiAgdHJ5IHtcbiAgICBhd2FpdCBwdWxsUHJvbWlzZS50aW1lb3V0KElPX1RJTUVPVVQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZG4ndCBwdWxsIHRoZSBmaWxlICcke3JlbGF0aXZlUGF0aH0nIGAgK1xuICAgICAgYHdpdGhpbiB0aGUgZ2l2ZW4gdGltZW91dCAke0lPX1RJTUVPVVR9bXMuIE9yaWdpbmFsIGVycm9yOiAke2UubWVzc2FnZX1gKTtcbiAgfVxuICByZXR1cm4gQnVmZmVyLmNvbmNhdChidWZmZXJzKS50b1N0cmluZygnYmFzZTY0Jyk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHB1bGxGb2xkZXJGcm9tUmVhbERldmljZSAoc2VydmljZSwgcmVsYXRpdmVQYXRoKSB7XG4gIGNvbnN0IHRtcEZvbGRlciA9IGF3YWl0IHRlbXBEaXIub3BlbkRpcigpO1xuICB0cnkge1xuICAgIGNvbnN0IGZvbGRlclBhdGggPSBwYXRoLmpvaW4odG1wRm9sZGVyLCByZWxhdGl2ZVBhdGgpO1xuICAgIGF3YWl0IG1rZGlycChmb2xkZXJQYXRoKTtcbiAgICBjb25zdCBwdWxsUHJvbWlzZXMgPSBbXTtcbiAgICBjb25zdCB3YWl0Rm9yUHVsbENodW5rcyA9IGFzeW5jICgpID0+IHtcbiAgICAgIGlmIChfLmlzRW1wdHkocHVsbFByb21pc2VzKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IEIuYWxsKHB1bGxQcm9taXNlcykudGltZW91dChJT19USU1FT1VUKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZG4ndCBwdWxsIGFsbCBpdGVtcyBpbiB0aGUgZm9sZGVyICcke3JlbGF0aXZlUGF0aH0nIGAgK1xuICAgICAgICAgIGB3aXRoaW4gdGhlIGdpdmVuIHRpbWVvdXQgJHtJT19USU1FT1VUfW1zLiBPcmlnaW5hbCBlcnJvcjogJHtlLm1lc3NhZ2V9YCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBhd2FpdCBzZXJ2aWNlLndhbGtEaXIocmVsYXRpdmVQYXRoLCB0cnVlLCBhc3luYyAoaXRlbVBhdGgsIGlzRGlyKSA9PiB7XG4gICAgICBjb25zdCBwYXRoT25TZXJ2ZXIgPSBwYXRoLmpvaW4odG1wRm9sZGVyLCBpdGVtUGF0aCk7XG4gICAgICBpZiAoaXNEaXIpIHtcbiAgICAgICAgYXdhaXQgZnMubWtkaXIocGF0aE9uU2VydmVyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCByZWFkU3RyZWFtID0gYXdhaXQgc2VydmljZS5jcmVhdGVSZWFkU3RyZWFtKGl0ZW1QYXRoLCB7YXV0b0Rlc3Ryb3k6IHRydWV9KTtcbiAgICAgIGNvbnN0IHdyaXRlU3RyZWFtID0gZnMuY3JlYXRlV3JpdGVTdHJlYW0ocGF0aE9uU2VydmVyLCB7YXV0b0Nsb3NlOiB0cnVlfSk7XG4gICAgICBwdWxsUHJvbWlzZXMucHVzaChuZXcgQigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHdyaXRlU3RyZWFtLm9uKCdjbG9zZScsIHJlc29sdmUpO1xuICAgICAgICBjb25zdCBvblN0cmVhbWluZ0Vycm9yID0gKGUpID0+IHtcbiAgICAgICAgICByZWFkU3RyZWFtLnVucGlwZSh3cml0ZVN0cmVhbSk7XG4gICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICB9O1xuICAgICAgICB3cml0ZVN0cmVhbS5vbignZXJyb3InLCBvblN0cmVhbWluZ0Vycm9yKTtcbiAgICAgICAgcmVhZFN0cmVhbS5vbignZXJyb3InLCBvblN0cmVhbWluZ0Vycm9yKTtcbiAgICAgIH0pKTtcbiAgICAgIHJlYWRTdHJlYW0ucGlwZSh3cml0ZVN0cmVhbSk7XG4gICAgICBpZiAocHVsbFByb21pc2VzLmxlbmd0aCAlIE1BWF9QVUxMX0NIVU5LX1NJWkUgPT09IDApIHtcbiAgICAgICAgYXdhaXQgd2FpdEZvclB1bGxDaHVua3MoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBXYWl0IGZvciB0aGUgcmVzdCBvZiB0aGUgY2h1bmtzXG4gICAgYXdhaXQgd2FpdEZvclB1bGxDaHVua3MoKTtcbiAgICByZXR1cm4gKGF3YWl0IHppcC50b0luTWVtb3J5WmlwKGZvbGRlclBhdGgsIHtcbiAgICAgIGVuY29kZVRvQmFzZTY0OiB0cnVlLFxuICAgIH0pKS50b1N0cmluZygpO1xuICB9IGZpbmFsbHkge1xuICAgIGF3YWl0IGZzLnJpbXJhZih0bXBGb2xkZXIpO1xuICB9XG59XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gQ29udGFpbmVyT2JqZWN0XG4gKlxuICogQHByb3BlcnR5IHtzdHJpbmd9IGJ1bmRsZUlkIC0gVGhlIHBhcnNlZCBidW5kbGUgaWRlbnRpZmllclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHBhdGhJbkNvbnRhaW5lciAtIFRoZSBhYnNvbHV0ZSBmdWxsIHBhdGggb2YgdGhlIGl0ZW0gb24gdGhlIGxvY2FsIGZpbGUgc3lzdGVtXG4gKiBAcHJvcGVydHkgez9zdHJpbmd9IGNvbnRhaW5lclR5cGUgLSBUaGUgY29udGFpbmVyIHR5cGVcbiAqL1xuXG4vKipcbiAqIFBhcnNlcyB0aGUgYWN0dWFsIHBhdGggYW5kIHRoZSBidW5kbGUgaWRlbnRpZmllciBmcm9tIHRoZSBnaXZlbiBwYXRoIHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSByZW1vdGVQYXRoIC0gVGhlIGdpdmVuIHBhdGggc3RyaW5nLiBUaGUgc3RyaW5nIHNob3VsZFxuICogbWF0Y2ggYENPTlRBSU5FUl9QQVRIX1BBVFRFUk5gIHJlZ2V4cCwgb3RoZXJ3aXNlIGFuIGVycm9yIGlzIGdvaW5nXG4gKiB0byBiZSB0aHJvd24uIEEgdmFsaWQgc3RyaW5nIGV4YW1wbGU6IGBAYnVuZGxlLmlkZW50aWZpZXI6Y29udGFpbmVyX3R5cGUvcmVsYXRpdmVfcGF0aF9pbl9jb250YWluZXJgXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufHN0cmluZ30gY29udGFpbmVyUm9vdFN1cHBsaWVyIC0gRWl0aGVyIGEgc3RyaW5nLCB0aGF0IGNvbnRhaW5zXG4gKiBmdWxsIHBhdGggdG8gdGhlIG1vdW50IHJvb3QgZm9yIHJlYWwgZGV2aWNlcyBvciBhIGZ1bmN0aW9uLCB3aGljaCBhY2NlcHRzIHR3byBwYXJhbWV0ZXJzXG4gKiAoYnVuZGxlIGlkZW50aWZpZXIgYW5kIG9wdGlvbmFsIGNvbnRhaW5lciB0eXBlKSBhbmQgcmV0dXJucyBmdWxsIHBhdGggdG8gY29udGFpbmVyXG4gKiByb290IGZvbGRlciBvbiB0aGUgbG9jYWwgZmlsZSBzeXN0ZW0sIGZvciBTaW11bGF0b3JcbiAqIEByZXR1cm5zIHtDb250YWluZXJPYmplY3R9XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHBhcnNlQ29udGFpbmVyUGF0aCAocmVtb3RlUGF0aCwgY29udGFpbmVyUm9vdFN1cHBsaWVyKSB7XG4gIGNvbnN0IG1hdGNoID0gQ09OVEFJTkVSX1BBVEhfUEFUVEVSTi5leGVjKHJlbW90ZVBhdGgpO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgbG9nLmVycm9yQW5kVGhyb3coYEl0IGlzIGV4cGVjdGVkIHRoYXQgcGFja2FnZSBpZGVudGlmaWVyIGAgK1xuICAgICAgYHN0YXJ0cyB3aXRoICcke0NPTlRBSU5FUl9QQVRIX01BUktFUn0nIGFuZCBpcyBzZXBhcmF0ZWQgZnJvbSB0aGUgYCArXG4gICAgICBgcmVsYXRpdmUgcGF0aCB3aXRoIGEgc2luZ2xlIHNsYXNoLiAnJHtyZW1vdGVQYXRofScgaXMgZ2l2ZW4gaW5zdGVhZGApO1xuICB9XG4gIGxldCBbLCBidW5kbGVJZCwgcmVsYXRpdmVQYXRoXSA9IG1hdGNoO1xuICBsZXQgY29udGFpbmVyVHlwZSA9IG51bGw7XG4gIGNvbnN0IHR5cGVTZXBhcmF0b3JQb3MgPSBidW5kbGVJZC5pbmRleE9mKENPTlRBSU5FUl9UWVBFX1NFUEFSQVRPUik7XG4gIC8vIFdlIG9ubHkgY29uc2lkZXIgY29udGFpbmVyIHR5cGUgZXhpc3RzIGlmIGl0cyBsZW5ndGggaXMgZ3JlYXRlciB0aGFuIHplcm9cbiAgLy8gbm90IGNvdW50aW5nIHRoZSBjb2xvblxuICBpZiAodHlwZVNlcGFyYXRvclBvcyA+IDAgJiYgdHlwZVNlcGFyYXRvclBvcyA8IGJ1bmRsZUlkLmxlbmd0aCAtIDEpIHtcbiAgICBjb250YWluZXJUeXBlID0gYnVuZGxlSWQuc3Vic3RyaW5nKHR5cGVTZXBhcmF0b3JQb3MgKyAxKTtcbiAgICBsb2cuZGVidWcoYFBhcnNlZCBjb250YWluZXIgdHlwZTogJHtjb250YWluZXJUeXBlfWApO1xuICAgIGJ1bmRsZUlkID0gYnVuZGxlSWQuc3Vic3RyaW5nKDAsIHR5cGVTZXBhcmF0b3JQb3MpO1xuICB9XG4gIGlmIChfLmlzTmlsKGNvbnRhaW5lclJvb3RTdXBwbGllcikpIHtcbiAgICBjb25zdCBwYXRoSW5Db250YWluZXIgPSByZWxhdGl2ZVBhdGg7XG4gICAgcmV0dXJuIHsgYnVuZGxlSWQsIHBhdGhJbkNvbnRhaW5lciwgY29udGFpbmVyVHlwZSB9O1xuICB9XG4gIGNvbnN0IGNvbnRhaW5lclJvb3QgPSBfLmlzRnVuY3Rpb24oY29udGFpbmVyUm9vdFN1cHBsaWVyKVxuICAgID8gYXdhaXQgY29udGFpbmVyUm9vdFN1cHBsaWVyKGJ1bmRsZUlkLCBjb250YWluZXJUeXBlKVxuICAgIDogY29udGFpbmVyUm9vdFN1cHBsaWVyO1xuICBjb25zdCBwYXRoSW5Db250YWluZXIgPSBwYXRoLnBvc2l4LnJlc29sdmUoY29udGFpbmVyUm9vdCwgcmVsYXRpdmVQYXRoKTtcbiAgdmVyaWZ5SXNTdWJQYXRoKHBhdGhJbkNvbnRhaW5lciwgY29udGFpbmVyUm9vdCk7XG4gIHJldHVybiB7YnVuZGxlSWQsIHBhdGhJbkNvbnRhaW5lciwgY29udGFpbmVyVHlwZX07XG59XG5cbi8qKlxuICogU2F2ZSB0aGUgZ2l2ZW4gYmFzZTY0IGRhdGEgY2h1bmsgYXMgYSBiaW5hcnkgZmlsZSBvbiB0aGUgU2ltdWxhdG9yIHVuZGVyIHRlc3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRldmljZSAtIFRoZSBkZXZpY2Ugb2JqZWN0LCB3aGljaCByZXByZXNlbnRzIHRoZSBkZXZpY2UgdW5kZXIgdGVzdC5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBUaGlzIG9iamVjdCBpcyBleHBlY3RlZCB0byBoYXZlIHRoZSBgdWRpZGAgcHJvcGVydHkgY29udGFpbmluZyB0aGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZCBkZXZpY2UgSUQuXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVtb3RlUGF0aCAtIFRoZSByZW1vdGUgcGF0aCBvbiB0aGUgZGV2aWNlLiBUaGlzIHZhcmlhYmxlIGNhbiBiZSBwcmVmaXhlZCB3aXRoXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1bmRsZSBpZCwgc28gdGhlbiB0aGUgZmlsZSB3aWxsIGJlIHVwbG9hZGVkIHRvIHRoZSBjb3JyZXNwb25kaW5nXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwcGxpY2F0aW9uIGNvbnRhaW5lciBpbnN0ZWFkIG9mIHRoZSBkZWZhdWx0IG1lZGlhIGZvbGRlciwgZm9yIGV4YW1wbGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0Bjb20ubXlhcHAuYmxhOmRhdGEvUmVsYXRpdmVQYXRoSW5Db250YWluZXIvMTExLnBuZycuIFRoZSAnQCcgY2hhcmFjdGVyIGF0IHRoZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZWdpbm5pbmcgb2YgdGhlIGFyZ3VtZW50IGlzIG1hbmRhdG9yeSBpbiBzdWNoIGNhc2UuIFRoZSBjb2xvbiBhdCB0aGUgZW5kIG9mIGJ1bmRsZSBpZGVudGlmaWVyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzIG9wdGlvbmFsIGFuZCBpcyB1c2VkIHRvIGRpc3Rpbmd1aXNoIHRoZSBjb250YWluZXIgdHlwZS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUG9zc2libGUgdmFsdWVzIHRoZXJlIGFyZSAnYXBwJywgJ2RhdGEnLCAnZ3JvdXBzJywgJzxBIHNwZWNpZmljIEFwcCBHcm91cCBjb250YWluZXI+Jy5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgJ2FwcCcuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSByZWxhdGl2ZSBmb2xkZXIgcGF0aCBpcyBpZ25vcmVkIGlmIHRoZSBmaWxlIGlzIGdvaW5nIHRvIGJlIHVwbG9hZGVkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIHRoZSBkZWZhdWx0IG1lZGlhIGZvbGRlciBhbmQgb25seSB0aGUgZmlsZSBuYW1lIGlzIGNvbnNpZGVyZWQgaW1wb3J0YW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2U2NERhdGEgLSBCYXNlLTY0IGVuY29kZWQgY29udGVudCBvZiB0aGUgZmlsZSB0byBiZSB1cGxvYWRlZC5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gcHVzaEZpbGVUb1NpbXVsYXRvciAoZGV2aWNlLCByZW1vdGVQYXRoLCBiYXNlNjREYXRhKSB7XG4gIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5mcm9tKGJhc2U2NERhdGEsICdiYXNlNjQnKTtcbiAgaWYgKENPTlRBSU5FUl9QQVRIX1BBVFRFUk4udGVzdChyZW1vdGVQYXRoKSkge1xuICAgIGNvbnN0IHtidW5kbGVJZCwgcGF0aEluQ29udGFpbmVyOiBkc3RQYXRofSA9IGF3YWl0IHBhcnNlQ29udGFpbmVyUGF0aChyZW1vdGVQYXRoLFxuICAgICAgYXN5bmMgKGFwcEJ1bmRsZSwgY29udGFpbmVyVHlwZSkgPT4gYXdhaXQgZGV2aWNlLnNpbWN0bC5nZXRBcHBDb250YWluZXIoYXBwQnVuZGxlLCBjb250YWluZXJUeXBlKSk7XG4gICAgbG9nLmluZm8oYFBhcnNlZCBidW5kbGUgaWRlbnRpZmllciAnJHtidW5kbGVJZH0nIGZyb20gJyR7cmVtb3RlUGF0aH0nLiBgICtcbiAgICAgIGBXaWxsIHB1dCB0aGUgZGF0YSBpbnRvICcke2RzdFBhdGh9J2ApO1xuICAgIGlmICghYXdhaXQgZnMuZXhpc3RzKHBhdGguZGlybmFtZShkc3RQYXRoKSkpIHtcbiAgICAgIGxvZy5kZWJ1ZyhgVGhlIGRlc3RpbmF0aW9uIGZvbGRlciAnJHtwYXRoLmRpcm5hbWUoZHN0UGF0aCl9JyBkb2VzIG5vdCBleGlzdC4gQ3JlYXRpbmcuLi5gKTtcbiAgICAgIGF3YWl0IG1rZGlycChwYXRoLmRpcm5hbWUoZHN0UGF0aCkpO1xuICAgIH1cbiAgICBhd2FpdCBmcy53cml0ZUZpbGUoZHN0UGF0aCwgYnVmZmVyKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgZHN0Rm9sZGVyID0gYXdhaXQgdGVtcERpci5vcGVuRGlyKCk7XG4gIGNvbnN0IGRzdFBhdGggPSBwYXRoLnJlc29sdmUoZHN0Rm9sZGVyLCBwYXRoLmJhc2VuYW1lKHJlbW90ZVBhdGgpKTtcbiAgdHJ5IHtcbiAgICBhd2FpdCBmcy53cml0ZUZpbGUoZHN0UGF0aCwgYnVmZmVyKTtcbiAgICBhd2FpdCBkZXZpY2Uuc2ltY3RsLmFkZE1lZGlhKGRzdFBhdGgpO1xuICB9IGZpbmFsbHkge1xuICAgIGF3YWl0IGZzLnJpbXJhZihkc3RGb2xkZXIpO1xuICB9XG59XG5cbi8qKlxuICogU2F2ZSB0aGUgZ2l2ZW4gYmFzZTY0IGRhdGEgY2h1bmsgYXMgYSBiaW5hcnkgZmlsZSBvbiB0aGUgZGV2aWNlIHVuZGVyIHRlc3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRldmljZSAtIFRoZSBkZXZpY2Ugb2JqZWN0LCB3aGljaCByZXByZXNlbnRzIHRoZSBkZXZpY2UgdW5kZXIgdGVzdC5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBUaGlzIG9iamVjdCBpcyBleHBlY3RlZCB0byBoYXZlIHRoZSBgdWRpZGAgcHJvcGVydHkgY29udGFpbmluZyB0aGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZCBkZXZpY2UgSUQuXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVtb3RlUGF0aCAtIFRoZSByZW1vdGUgcGF0aCBvbiB0aGUgZGV2aWNlLiBUaGlzIHZhcmlhYmxlIGNhbiBiZSBwcmVmaXhlZCB3aXRoXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1bmRsZSBpZCwgc28gdGhlbiB0aGUgZmlsZSB3aWxsIGJlIHVwbG9hZGVkIHRvIHRoZSBjb3JyZXNwb25kaW5nXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwcGxpY2F0aW9uIGNvbnRhaW5lciBpbnN0ZWFkIG9mIHRoZSBkZWZhdWx0IG1lZGlhIGZvbGRlci4gVXNlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEA8YXBwX2J1bmRsZV9pZD46PG9wdGlvbmFsX2NvbnRhaW5lcl90eXBlPi88cGF0aF90b190aGVfZmlsZV9vcl9mb2xkZXJfaW5zaWRlX2NvbnRhaW5lcj5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0IHRvIHB1bGwgYSBmaWxlIG9yIGEgZm9sZGVyIGZyb20gYW4gYXBwbGljYXRpb24gY29udGFpbmVyIG9mIHRoZSBnaXZlbiB0eXBlLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgb25seSBzdXBwb3J0ZWQgY29udGFpbmVyIHR5cGUgaXMgJ2RvY3VtZW50cycuIElmIHRoZSBjb250YWluZXIgdHlwZSBpcyBub3Qgc2V0XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cGxpY2l0bHkgZm9yIGEgYnVuZGxlIGlkLCB0aGVuIHRoZSBkZWZhdWx0IGFwcGxpY2F0aW9uIGNvbnRhaW5lciBpcyBnb2luZyB0byBiZSBtb3VudGVkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChha2EgLS1jb250YWluZXIgaWZ1c2UgYXJndW1lbnQpXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuZy4gSWYgYEBjb20ubXlhcHAuYmxhOmRvY3VtZW50cy8xMTEucG5nYCBpcyBwcm92aWRlZCxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgT24gTXkgaVBob25lLzxhcHAgbmFtZT5gIGluIEZpbGVzIGFwcCB3aWxsIGJlIG1vdW50ZWQgaW4gdGhlIGhvc3QgbWFjaGluZS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBCYXNlNjQgZW5jb2RlZCBgMTExLnBuZ2Agd2lsbCBiZSBwdXNoZWQgaW50byBgT24gTXkgaVBob25lLzxhcHAgbmFtZT4vMTExLnBuZ2BcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcyBiYXNlNjQgZGVjb2RlZCBkYXRhLlxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2U2NERhdGEgLSBCYXNlLTY0IGVuY29kZWQgY29udGVudCBvZiB0aGUgZmlsZSB0byBiZSB1cGxvYWRlZC5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gcHVzaEZpbGVUb1JlYWxEZXZpY2UgKGRldmljZSwgcmVtb3RlUGF0aCwgYmFzZTY0RGF0YSkge1xuICBjb25zdCB7c2VydmljZSwgcmVsYXRpdmVQYXRofSA9IGF3YWl0IGNyZWF0ZVNlcnZpY2UoZGV2aWNlLnVkaWQsIHJlbW90ZVBhdGgpO1xuICB0cnkge1xuICAgIGF3YWl0IG1rZGlycERldmljZShzZXJ2aWNlLCBwYXRoLmRpcm5hbWUocmVsYXRpdmVQYXRoKSk7XG4gICAgY29uc3Qgc3RyZWFtID0gYXdhaXQgc2VydmljZS5jcmVhdGVXcml0ZVN0cmVhbShyZWxhdGl2ZVBhdGgsIHthdXRvRGVzdHJveTogdHJ1ZX0pO1xuICAgIGxldCBwdXNoRXJyb3IgPSBudWxsO1xuICAgIGNvbnN0IHB1c2hQcm9taXNlID0gbmV3IEIoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgc3RyZWFtLm9uKCdlcnJvcicsIChlKSA9PiB7XG4gICAgICAgIHB1c2hFcnJvciA9IGU7XG4gICAgICB9KTtcbiAgICAgIHN0cmVhbS5vbignY2xvc2UnLCAoKSA9PiB7XG4gICAgICAgIGlmIChwdXNoRXJyb3IpIHtcbiAgICAgICAgICByZWplY3QocHVzaEVycm9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHN0cmVhbS53cml0ZShCdWZmZXIuZnJvbShiYXNlNjREYXRhLCAnYmFzZTY0JykpO1xuICAgIHN0cmVhbS5lbmQoKTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgcHVzaFByb21pc2UudGltZW91dChJT19USU1FT1VUKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBwdXNoIHRoZSBmaWxlIHdpdGhpbiB0aGUgZ2l2ZW4gdGltZW91dCAke0lPX1RJTUVPVVR9bXMuIGAgK1xuICAgICAgICBgT3JpZ2luYWwgZXJyb3I6ICR7ZS5tZXNzYWdlfWApO1xuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICBzZXJ2aWNlLmNsb3NlKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgdGhlIGNvbnRlbnQgb2YgZ2l2ZW4gZmlsZSBvciBmb2xkZXIgZnJvbSBpT1MgU2ltdWxhdG9yIGFuZCByZXR1cm4gaXQgYXMgYmFzZS02NCBlbmNvZGVkIHN0cmluZy5cbiAqIEZvbGRlciBjb250ZW50IGlzIHJlY3Vyc2l2ZWx5IHBhY2tlZCBpbnRvIGEgemlwIGFyY2hpdmUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRldmljZSAtIFRoZSBkZXZpY2Ugb2JqZWN0LCB3aGljaCByZXByZXNlbnRzIHRoZSBkZXZpY2UgdW5kZXIgdGVzdC5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBUaGlzIG9iamVjdCBpcyBleHBlY3RlZCB0byBoYXZlIHRoZSBgdWRpZGAgcHJvcGVydHkgY29udGFpbmluZyB0aGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZCBkZXZpY2UgSUQuXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVtb3RlUGF0aCAtIFRoZSBwYXRoIHRvIGEgZmlsZSBvciBhIGZvbGRlciwgd2hpY2ggZXhpc3RzIGluIHRoZSBjb3JyZXNwb25kaW5nIGFwcGxpY2F0aW9uXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lciBvbiBTaW11bGF0b3IuIFVzZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBAPGFwcF9idW5kbGVfaWQ+OjxvcHRpb25hbF9jb250YWluZXJfdHlwZT4vPHBhdGhfdG9fdGhlX2ZpbGVfb3JfZm9sZGVyX2luc2lkZV9jb250YWluZXI+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdCB0byBwdWxsIGEgZmlsZSBvciBhIGZvbGRlciBmcm9tIGFuIGFwcGxpY2F0aW9uIGNvbnRhaW5lciBvZiB0aGUgZ2l2ZW4gdHlwZS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUG9zc2libGUgY29udGFpbmVyIHR5cGVzIGFyZSAnYXBwJywgJ2RhdGEnLCAnZ3JvdXBzJywgJzxBIHNwZWNpZmljIEFwcCBHcm91cCBjb250YWluZXI+Jy5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIGRlZmF1bHQgdHlwZSBpcyAnYXBwJy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNGaWxlIC0gV2hldGhlciB0aGUgZGVzdGluYXRpb24gaXRlbSBpcyBhIGZpbGUgb3IgYSBmb2xkZXJcbiAqIEByZXR1cm5zIHtzdHJpbmd9IEJhc2UtNjQgZW5jb2RlZCBjb250ZW50IG9mIHRoZSBmaWxlLlxuICovXG5hc3luYyBmdW5jdGlvbiBwdWxsRnJvbVNpbXVsYXRvciAoZGV2aWNlLCByZW1vdGVQYXRoLCBpc0ZpbGUpIHtcbiAgbGV0IHBhdGhPblNlcnZlcjtcbiAgaWYgKENPTlRBSU5FUl9QQVRIX1BBVFRFUk4udGVzdChyZW1vdGVQYXRoKSkge1xuICAgIGNvbnN0IHtidW5kbGVJZCwgcGF0aEluQ29udGFpbmVyOiBkc3RQYXRofSA9IGF3YWl0IHBhcnNlQ29udGFpbmVyUGF0aChyZW1vdGVQYXRoLFxuICAgICAgYXN5bmMgKGFwcEJ1bmRsZSwgY29udGFpbmVyVHlwZSkgPT4gYXdhaXQgZGV2aWNlLnNpbWN0bC5nZXRBcHBDb250YWluZXIoYXBwQnVuZGxlLCBjb250YWluZXJUeXBlKSk7XG4gICAgbG9nLmluZm8oYFBhcnNlZCBidW5kbGUgaWRlbnRpZmllciAnJHtidW5kbGVJZH0nIGZyb20gJyR7cmVtb3RlUGF0aH0nLiBgICtcbiAgICAgIGBXaWxsIGdldCB0aGUgZGF0YSBmcm9tICcke2RzdFBhdGh9J2ApO1xuICAgIHBhdGhPblNlcnZlciA9IGRzdFBhdGg7XG4gIH0gZWxzZSB7XG4gICAgY29uc3Qgc2ltUm9vdCA9IGRldmljZS5nZXREaXIoKTtcbiAgICBwYXRoT25TZXJ2ZXIgPSBwYXRoLnBvc2l4LmpvaW4oc2ltUm9vdCwgcmVtb3RlUGF0aCk7XG4gICAgdmVyaWZ5SXNTdWJQYXRoKHBhdGhPblNlcnZlciwgc2ltUm9vdCk7XG4gICAgbG9nLmluZm8oYEdvdCB0aGUgZnVsbCBpdGVtIHBhdGg6ICR7cGF0aE9uU2VydmVyfWApO1xuICB9XG4gIGlmICghYXdhaXQgZnMuZXhpc3RzKHBhdGhPblNlcnZlcikpIHtcbiAgICBsb2cuZXJyb3JBbmRUaHJvdyhgVGhlIHJlbW90ZSAke2lzRmlsZSA/ICdmaWxlJyA6ICdmb2xkZXInfSBhdCAnJHtwYXRoT25TZXJ2ZXJ9JyBkb2VzIG5vdCBleGlzdGApO1xuICB9XG4gIGNvbnN0IGJ1ZmZlciA9IGlzRmlsZVxuICAgID8gYXdhaXQgdXRpbC50b0luTWVtb3J5QmFzZTY0KHBhdGhPblNlcnZlcilcbiAgICA6IGF3YWl0IHppcC50b0luTWVtb3J5WmlwKHBhdGhPblNlcnZlciwge2VuY29kZVRvQmFzZTY0OiB0cnVlfSk7XG4gIHJldHVybiBidWZmZXIudG9TdHJpbmcoKTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGNvbnRlbnQgb2YgZ2l2ZW4gZmlsZSBvciBmb2xkZXIgZnJvbSB0aGUgcmVhbCBkZXZpY2UgdW5kZXIgdGVzdCBhbmQgcmV0dXJuIGl0IGFzIGJhc2UtNjQgZW5jb2RlZCBzdHJpbmcuXG4gKiBGb2xkZXIgY29udGVudCBpcyByZWN1cnNpdmVseSBwYWNrZWQgaW50byBhIHppcCBhcmNoaXZlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZXZpY2UgLSBUaGUgZGV2aWNlIG9iamVjdCwgd2hpY2ggcmVwcmVzZW50cyB0aGUgZGV2aWNlIHVuZGVyIHRlc3QuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgVGhpcyBvYmplY3QgaXMgZXhwZWN0ZWQgdG8gaGF2ZSB0aGUgYHVkaWRgIHByb3BlcnR5IGNvbnRhaW5pbmcgdGhlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWQgZGV2aWNlIElELlxuICogQHBhcmFtIHtzdHJpbmd9IHJlbW90ZVBhdGggLSBUaGUgcGF0aCB0byBhbiBleGlzdGluZyByZW1vdGUgZmlsZSBvbiB0aGUgZGV2aWNlLiBUaGlzIHZhcmlhYmxlIGNhbiBiZSBwcmVmaXhlZCB3aXRoXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1bmRsZSBpZCwgc28gdGhlbiB0aGUgZmlsZSB3aWxsIGJlIGRvd25sb2FkZWQgZnJvbSB0aGUgY29ycmVzcG9uZGluZ1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcHBsaWNhdGlvbiBjb250YWluZXIgaW5zdGVhZCBvZiB0aGUgZGVmYXVsdCBtZWRpYSBmb2xkZXIuIFVzZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBAPGFwcF9idW5kbGVfaWQ+OjxvcHRpb25hbF9jb250YWluZXJfdHlwZT4vPHBhdGhfdG9fdGhlX2ZpbGVfb3JfZm9sZGVyX2luc2lkZV9jb250YWluZXI+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdCB0byBwdWxsIGEgZmlsZSBvciBhIGZvbGRlciBmcm9tIGFuIGFwcGxpY2F0aW9uIGNvbnRhaW5lciBvZiB0aGUgZ2l2ZW4gdHlwZS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIG9ubHkgc3VwcG9ydGVkIGNvbnRhaW5lciB0eXBlIGlzICdkb2N1bWVudHMnLiBJZiB0aGUgY29udGFpbmVyIHR5cGUgaXMgbm90IHNldFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBsaWNpdGx5IGZvciBhIGJ1bmRsZSBpZCwgdGhlbiB0aGUgZGVmYXVsdCBhcHBsaWNhdGlvbiBjb250YWluZXIgaXMgZ29pbmcgdG8gYmUgbW91bnRlZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYWthIC0tY29udGFpbmVyIGlmdXNlIGFyZ3VtZW50KVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLmcuIElmIGBAY29tLm15YXBwLmJsYTpkb2N1bWVudHMvMTExLnBuZ2AgaXMgcHJvdmlkZWQsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYE9uIE15IGlQaG9uZS88YXBwIG5hbWU+YCBpbiBGaWxlcyBhcHAgd2lsbCBiZSBtb3VudGVkIGluIHRoZSBob3N0IG1hY2hpbmUuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYE9uIE15IGlQaG9uZS88YXBwIG5hbWU+LzExMS5wbmdgIHdpbCBiZSBwdWxsZWQgaW50byB0aGUgbW91bnRlZCBob3N0IG1hY2hpbmVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmQgQXBwaXVtIHJldHVybnMgdGhlIGRhdGEgYXMgYmFzZTY0LWVuY29kZWQgc3RyaW5nIHRvIGNsaWVudC5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgQGNvbS5teWFwcC5ibGE6ZG9jdW1lbnRzL2AgbWVhbnMgYE9uIE15IGlQaG9uZS88YXBwIG5hbWU+YC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNGaWxlIC0gV2hldGhlciB0aGUgZGVzdGluYXRpb24gaXRlbSBpcyBhIGZpbGUgb3IgYSBmb2xkZXJcbiAqIEByZXR1cm4ge3N0cmluZ30gQmFzZS02NCBlbmNvZGVkIGNvbnRlbnQgb2YgdGhlIHJlbW90ZSBmaWxlXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHB1bGxGcm9tUmVhbERldmljZSAoZGV2aWNlLCByZW1vdGVQYXRoLCBpc0ZpbGUpIHtcbiAgY29uc3Qge3NlcnZpY2UsIHJlbGF0aXZlUGF0aH0gPSBhd2FpdCBjcmVhdGVTZXJ2aWNlKGRldmljZS51ZGlkLCByZW1vdGVQYXRoKTtcbiAgdHJ5IHtcbiAgICBjb25zdCBmaWxlSW5mbyA9IGF3YWl0IHNlcnZpY2UuZ2V0RmlsZUluZm8ocmVsYXRpdmVQYXRoKTtcbiAgICBpZiAoaXNGaWxlICYmIGZpbGVJbmZvLmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIHJlcXVlc3RlZCBwYXRoIGlzIG5vdCBhIGZpbGUuIFBhdGg6ICcke3JlbW90ZVBhdGh9J2ApO1xuICAgIH1cbiAgICBpZiAoIWlzRmlsZSAmJiAhZmlsZUluZm8uaXNEaXJlY3RvcnkoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgcmVxdWVzdGVkIHBhdGggaXMgbm90IGEgZm9sZGVyLiBQYXRoOiAnJHtyZW1vdGVQYXRofSdgKTtcbiAgICB9XG5cbiAgICBpZiAoZmlsZUluZm8uaXNGaWxlKCkpIHtcbiAgICAgIHJldHVybiBhd2FpdCBwdWxsRmlsZUZyb21SZWFsRGV2aWNlKHNlcnZpY2UsIHJlbGF0aXZlUGF0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBhd2FpdCBwdWxsRm9sZGVyRnJvbVJlYWxEZXZpY2Uoc2VydmljZSwgcmVsYXRpdmVQYXRoKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoZS5tZXNzYWdlLmluY2x1ZGVzKE9CSkVDVF9OT1RfRk9VTkRfRVJST1JfTUVTU0FHRSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgUGF0aCAnJHtyZW1vdGVQYXRofScgZG9lcyBub3QgZXhpc3Qgb24gdGhlIGRldmljZWApO1xuICAgIH1cbiAgICB0aHJvdyBlO1xuICB9IGZpbmFsbHkge1xuICAgIHNlcnZpY2UuY2xvc2UoKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZSB0aGUgZmlsZSBvciBmb2xkZXIgZnJvbSB0aGUgZGV2aWNlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRldmljZSAtIFRoZSBkZXZpY2Ugb2JqZWN0LCB3aGljaCByZXByZXNlbnRzIHRoZSBkZXZpY2UgdW5kZXIgdGVzdC5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBUaGlzIG9iamVjdCBpcyBleHBlY3RlZCB0byBoYXZlIHRoZSBgdWRpZGAgcHJvcGVydHkgY29udGFpbmluZyB0aGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZCBkZXZpY2UgSUQuXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVtb3RlUGF0aCAtIFRoZSBwYXRoIHRvIGEgZmlsZSBvciBhIGZvbGRlciwgd2hpY2ggZXhpc3RzIGluIHRoZSBjb3JyZXNwb25kaW5nIGFwcGxpY2F0aW9uXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lciBvbiBTaW11bGF0b3IuIFVzZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBAPGFwcF9idW5kbGVfaWQ+OjxvcHRpb25hbF9jb250YWluZXJfdHlwZT4vPHBhdGhfdG9fdGhlX2ZpbGVfb3JfZm9sZGVyX2luc2lkZV9jb250YWluZXI+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdCB0byBwdWxsIGEgZmlsZSBvciBhIGZvbGRlciBmcm9tIGFuIGFwcGxpY2F0aW9uIGNvbnRhaW5lciBvZiB0aGUgZ2l2ZW4gdHlwZS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUG9zc2libGUgY29udGFpbmVyIHR5cGVzIGFyZSAnYXBwJywgJ2RhdGEnLCAnZ3JvdXBzJywgJzxBIHNwZWNpZmljIEFwcCBHcm91cCBjb250YWluZXI+Jy5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIGRlZmF1bHQgdHlwZSBpcyAnYXBwJy5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZGVsZXRlRnJvbVNpbXVsYXRvciAoZGV2aWNlLCByZW1vdGVQYXRoKSB7XG4gIGxldCBwYXRoT25TZXJ2ZXI7XG4gIGlmIChDT05UQUlORVJfUEFUSF9QQVRURVJOLnRlc3QocmVtb3RlUGF0aCkpIHtcbiAgICBjb25zdCB7YnVuZGxlSWQsIHBhdGhJbkNvbnRhaW5lcjogZHN0UGF0aH0gPSBhd2FpdCBwYXJzZUNvbnRhaW5lclBhdGgocmVtb3RlUGF0aCxcbiAgICAgIGFzeW5jIChhcHBCdW5kbGUsIGNvbnRhaW5lclR5cGUpID0+IGF3YWl0IGRldmljZS5zaW1jdGwuZ2V0QXBwQ29udGFpbmVyKGFwcEJ1bmRsZSwgY29udGFpbmVyVHlwZSkpO1xuICAgIGxvZy5pbmZvKGBQYXJzZWQgYnVuZGxlIGlkZW50aWZpZXIgJyR7YnVuZGxlSWR9JyBmcm9tICcke3JlbW90ZVBhdGh9Jy4gYCArXG4gICAgICBgJyR7ZHN0UGF0aH0nIHdpbGwgYmUgZGVsZXRlZGApO1xuICAgIHBhdGhPblNlcnZlciA9IGRzdFBhdGg7XG4gIH0gZWxzZSB7XG4gICAgY29uc3Qgc2ltUm9vdCA9IGRldmljZS5nZXREaXIoKTtcbiAgICBwYXRoT25TZXJ2ZXIgPSBwYXRoLnBvc2l4LmpvaW4oc2ltUm9vdCwgcmVtb3RlUGF0aCk7XG4gICAgdmVyaWZ5SXNTdWJQYXRoKHBhdGhPblNlcnZlciwgc2ltUm9vdCk7XG4gICAgbG9nLmluZm8oYEdvdCB0aGUgZnVsbCBwYXRoOiAke3BhdGhPblNlcnZlcn1gKTtcbiAgfVxuICBpZiAoIWF3YWl0IGZzLmV4aXN0cyhwYXRoT25TZXJ2ZXIpKSB7XG4gICAgbG9nLmVycm9yQW5kVGhyb3coYFRoZSByZW1vdGUgcGF0aCBhdCAnJHtwYXRoT25TZXJ2ZXJ9JyBkb2VzIG5vdCBleGlzdGApO1xuICB9XG4gIGF3YWl0IGZzLnJpbXJhZihwYXRoT25TZXJ2ZXIpO1xufVxuXG4vKipcbiAqIFJlbW92ZSB0aGUgZmlsZSBvciBmb2xkZXIgZnJvbSB0aGUgZGV2aWNlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRldmljZSAtIFRoZSBkZXZpY2Ugb2JqZWN0LCB3aGljaCByZXByZXNlbnRzIHRoZSBkZXZpY2UgdW5kZXIgdGVzdC5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBUaGlzIG9iamVjdCBpcyBleHBlY3RlZCB0byBoYXZlIHRoZSBgdWRpZGAgcHJvcGVydHkgY29udGFpbmluZyB0aGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZCBkZXZpY2UgSUQuXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVtb3RlUGF0aCAtIFRoZSBwYXRoIHRvIGFuIGV4aXN0aW5nIHJlbW90ZSBmaWxlIG9uIHRoZSBkZXZpY2UuIFRoaXMgdmFyaWFibGUgY2FuIGJlIHByZWZpeGVkIHdpdGhcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVuZGxlIGlkLCBzbyB0aGVuIHRoZSBmaWxlIHdpbGwgYmUgZG93bmxvYWRlZCBmcm9tIHRoZSBjb3JyZXNwb25kaW5nXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwcGxpY2F0aW9uIGNvbnRhaW5lciBpbnN0ZWFkIG9mIHRoZSBkZWZhdWx0IG1lZGlhIGZvbGRlci4gVXNlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEA8YXBwX2J1bmRsZV9pZD46PG9wdGlvbmFsX2NvbnRhaW5lcl90eXBlPi88cGF0aF90b190aGVfZmlsZV9vcl9mb2xkZXJfaW5zaWRlX2NvbnRhaW5lcj5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0IHRvIHB1bGwgYSBmaWxlIG9yIGEgZm9sZGVyIGZyb20gYW4gYXBwbGljYXRpb24gY29udGFpbmVyIG9mIHRoZSBnaXZlbiB0eXBlLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgb25seSBzdXBwb3J0ZWQgY29udGFpbmVyIHR5cGUgaXMgJ2RvY3VtZW50cycuIElmIHRoZSBjb250YWluZXIgdHlwZSBpcyBub3Qgc2V0XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cGxpY2l0bHkgZm9yIGEgYnVuZGxlIGlkLCB0aGVuIHRoZSBkZWZhdWx0IGFwcGxpY2F0aW9uIGNvbnRhaW5lciBpcyBnb2luZyB0byBiZSBtb3VudGVkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChha2EgLS1jb250YWluZXIgaWZ1c2UgYXJndW1lbnQpXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuZy4gSWYgYEBjb20ubXlhcHAuYmxhOmRvY3VtZW50cy8xMTEucG5nYCBpcyBwcm92aWRlZCxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgT24gTXkgaVBob25lLzxhcHAgbmFtZT5gIGluIEZpbGVzIGFwcCB3aWxsIGJlIG1vdW50ZWQgaW4gdGhlIGhvc3QgbWFjaGluZS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgT24gTXkgaVBob25lLzxhcHAgbmFtZT4vMTExLnBuZ2Agd2lsIGJlIHB1bGxlZCBpbnRvIHRoZSBtb3VudGVkIGhvc3QgbWFjaGluZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuZCBBcHBpdW0gcmV0dXJucyB0aGUgZGF0YSBhcyBiYXNlNjQtZW5jb2RlZCBzdHJpbmcgdG8gY2xpZW50LlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBAY29tLm15YXBwLmJsYTpkb2N1bWVudHMvYCBtZWFucyBgT24gTXkgaVBob25lLzxhcHAgbmFtZT5gLlxuICovXG5hc3luYyBmdW5jdGlvbiBkZWxldGVGcm9tUmVhbERldmljZSAoZGV2aWNlLCByZW1vdGVQYXRoKSB7XG4gIGNvbnN0IHsgc2VydmljZSwgcmVsYXRpdmVQYXRoIH0gPSBhd2FpdCBjcmVhdGVTZXJ2aWNlKGRldmljZS51ZGlkLCByZW1vdGVQYXRoKTtcbiAgdHJ5IHtcbiAgICBhd2FpdCBzZXJ2aWNlLmRlbGV0ZURpcmVjdG9yeShyZWxhdGl2ZVBhdGgpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKGUubWVzc2FnZS5pbmNsdWRlcyhPQkpFQ1RfTk9UX0ZPVU5EX0VSUk9SX01FU1NBR0UpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFBhdGggJyR7cmVtb3RlUGF0aH0nIGRvZXMgbm90IGV4aXN0IG9uIHRoZSBkZXZpY2VgKTtcbiAgICB9XG4gICAgdGhyb3cgZTtcbiAgfSBmaW5hbGx5IHtcbiAgICBzZXJ2aWNlLmNsb3NlKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgYnVuZGxlSWRzIHdoaWNoIGNhbiBtb3VudCBieSBgLS1kb2N1bWVudHNgIGZsYWdcbiAqXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHVkaWQgLSBUaGUgdWRpZCBvZiB0aGUgdGFyZ2V0IGRldmljZVxuICogQHJldHVybnMge0FycmF5PHN0cmluZz59IEEgbGlzdCBvZiBVc2VyIGxldmVsIGFwcHMnIGJ1bmRsZSBpZHMgd2hpY2ggaGFzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgJ1VJRmlsZVNoYXJpbmdFbmFibGVkJyBhdHRyaWJ1dGUuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgT25seSB1c2VyIGFwcHMgbWlnaHQgaGF2ZSBpdC5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0QXZhaWxhYmxlQnVuZGxlSWRzICh1ZGlkKSB7XG4gIGNvbnN0IHNlcnZpY2UgPSBhd2FpdCBzZXJ2aWNlcy5zdGFydEluc3RhbGxhdGlvblByb3h5U2VydmljZSh1ZGlkKTtcbiAgdHJ5IHtcbiAgICBjb25zdCBhcHBsaWNhdGlvbnMgPSBhd2FpdCBzZXJ2aWNlLmxpc3RBcHBsaWNhdGlvbnMoe2FwcGxpY2F0aW9uVHlwZTogJ1VzZXInfSk7XG4gICAgY29uc3QgYnVuZGxlSWRzID0gW107XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoYXBwbGljYXRpb25zKSkge1xuICAgICAgaWYgKCF2YWx1ZS5VSUZpbGVTaGFyaW5nRW5hYmxlZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGJ1bmRsZUlkcy5wdXNoKGtleSk7XG4gICAgfVxuICAgIHJldHVybiBidW5kbGVJZHM7XG4gIH0gZmluYWxseSB7XG4gICAgc2VydmljZS5jbG9zZSgpO1xuICB9XG59XG5cblxuY29tbWFuZHMucHVzaEZpbGUgPSBhc3luYyBmdW5jdGlvbiBwdXNoRmlsZSAocmVtb3RlUGF0aCwgYmFzZTY0RGF0YSkge1xuICBpZiAocmVtb3RlUGF0aC5lbmRzV2l0aCgnLycpKSB7XG4gICAgbG9nLmVycm9yQW5kVGhyb3coYEl0IGlzIGV4cGVjdGVkIHRoYXQgcmVtb3RlIHBhdGggcG9pbnRzIHRvIGEgZmlsZSBhbmQgbm90IHRvIGEgZm9sZGVyLiBgICtcbiAgICAgICAgICAgICAgICAgICAgICBgJyR7cmVtb3RlUGF0aH0nIGlzIGdpdmVuIGluc3RlYWRgKTtcbiAgfVxuICBpZiAoXy5pc0FycmF5KGJhc2U2NERhdGEpKSB7XG4gICAgLy8gc29tZSBjbGllbnRzIChhaGVtKSBqYXZhLCBzZW5kIGEgYnl0ZSBhcnJheSBlbmNvZGluZyB1dGY4IGNoYXJhY3RlcnNcbiAgICAvLyBpbnN0ZWFkIG9mIGEgc3RyaW5nLCB3aGljaCB3b3VsZCBiZSBpbmZpbml0ZWx5IGJldHRlciFcbiAgICBiYXNlNjREYXRhID0gQnVmZmVyLmZyb20oYmFzZTY0RGF0YSkudG9TdHJpbmcoJ3V0ZjgnKTtcbiAgfVxuICByZXR1cm4gdGhpcy5pc1NpbXVsYXRvcigpXG4gICAgPyBhd2FpdCBwdXNoRmlsZVRvU2ltdWxhdG9yKHRoaXMub3B0cy5kZXZpY2UsIHJlbW90ZVBhdGgsIGJhc2U2NERhdGEpXG4gICAgOiBhd2FpdCBwdXNoRmlsZVRvUmVhbERldmljZSh0aGlzLm9wdHMuZGV2aWNlLCByZW1vdGVQYXRoLCBiYXNlNjREYXRhKTtcbn07XG5cbmNvbW1hbmRzLnB1bGxGaWxlID0gYXN5bmMgZnVuY3Rpb24gcHVsbEZpbGUgKHJlbW90ZVBhdGgpIHtcbiAgaWYgKHJlbW90ZVBhdGguZW5kc1dpdGgoJy8nKSkge1xuICAgIGxvZy5lcnJvckFuZFRocm93KGBJdCBpcyBleHBlY3RlZCB0aGF0IHJlbW90ZSBwYXRoIHBvaW50cyB0byBhIGZpbGUgYW5kIG5vdCB0byBhIGZvbGRlci4gYCArXG4gICAgICAgICAgICAgICAgICAgICAgYCcke3JlbW90ZVBhdGh9JyBpcyBnaXZlbiBpbnN0ZWFkYCk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuaXNTaW11bGF0b3IoKVxuICAgID8gYXdhaXQgcHVsbEZyb21TaW11bGF0b3IodGhpcy5vcHRzLmRldmljZSwgcmVtb3RlUGF0aCwgdHJ1ZSlcbiAgICA6IGF3YWl0IHB1bGxGcm9tUmVhbERldmljZSh0aGlzLm9wdHMuZGV2aWNlLCByZW1vdGVQYXRoLCB0cnVlKTtcbn07XG5cbmFzeW5jIGZ1bmN0aW9uIGRlbGV0ZUZpbGVPckZvbGRlciAoZGV2aWNlLCByZW1vdGVQYXRoLCBpc1NpbXVsYXRvcikge1xuICByZXR1cm4gaXNTaW11bGF0b3JcbiAgICA/IGF3YWl0IGRlbGV0ZUZyb21TaW11bGF0b3IoZGV2aWNlLCByZW1vdGVQYXRoKVxuICAgIDogYXdhaXQgZGVsZXRlRnJvbVJlYWxEZXZpY2UoZGV2aWNlLCByZW1vdGVQYXRoKTtcbn1cblxuY29tbWFuZHMubW9iaWxlRGVsZXRlRm9sZGVyID0gYXN5bmMgZnVuY3Rpb24gbW9iaWxlRGVsZXRlRm9sZGVyIChvcHRzID0ge30pIHtcbiAgbGV0IHtyZW1vdGVQYXRofSA9IG9wdHM7XG4gIGlmICghcmVtb3RlUGF0aC5lbmRzV2l0aCgnLycpKSB7XG4gICAgcmVtb3RlUGF0aCA9IGAke3JlbW90ZVBhdGh9L2A7XG4gIH1cbiAgcmV0dXJuIGF3YWl0IGRlbGV0ZUZpbGVPckZvbGRlcih0aGlzLm9wdHMuZGV2aWNlLCByZW1vdGVQYXRoLCB0aGlzLmlzU2ltdWxhdG9yKCkpO1xufTtcblxuY29tbWFuZHMubW9iaWxlRGVsZXRlRmlsZSA9IGFzeW5jIGZ1bmN0aW9uIG1vYmlsZURlbGV0ZUZpbGUgKG9wdHMgPSB7fSkge1xuICBjb25zdCB7cmVtb3RlUGF0aH0gPSBvcHRzO1xuICBpZiAocmVtb3RlUGF0aC5lbmRzV2l0aCgnLycpKSB7XG4gICAgbG9nLmVycm9yQW5kVGhyb3coYEl0IGlzIGV4cGVjdGVkIHRoYXQgcmVtb3RlIHBhdGggcG9pbnRzIHRvIGEgZmlsZSBhbmQgbm90IHRvIGEgZm9sZGVyLiBgICtcbiAgICAgICAgICAgICAgICAgICAgICBgJyR7cmVtb3RlUGF0aH0nIGlzIGdpdmVuIGluc3RlYWRgKTtcbiAgfVxuICByZXR1cm4gYXdhaXQgZGVsZXRlRmlsZU9yRm9sZGVyKHRoaXMub3B0cy5kZXZpY2UsIHJlbW90ZVBhdGgsIHRoaXMuaXNTaW11bGF0b3IoKSk7XG59O1xuXG5jb21tYW5kcy5nZXRTaW1GaWxlRnVsbFBhdGggPSBhc3luYyBmdW5jdGlvbiBnZXRTaW1GaWxlRnVsbFBhdGggKHJlbW90ZVBhdGgpIHtcbiAgbGV0IGJhc2VQYXRoID0gdGhpcy5vcHRzLmRldmljZS5nZXREaXIoKTtcbiAgbGV0IGFwcE5hbWUgPSBudWxsO1xuXG4gIGlmICh0aGlzLm9wdHMuYXBwKSB7XG4gICAgbGV0IGFwcE5hbWVSZWdleCA9IG5ldyBSZWdFeHAoYFxcXFwke3BhdGguc2VwfShbXFxcXHctXStcXFxcLmFwcClgKTtcbiAgICBsZXQgYXBwTmFtZU1hdGNoZXMgPSBhcHBOYW1lUmVnZXguZXhlYyh0aGlzLm9wdHMuYXBwKTtcbiAgICBpZiAoYXBwTmFtZU1hdGNoZXMpIHtcbiAgICAgIGFwcE5hbWUgPSBhcHBOYW1lTWF0Y2hlc1sxXTtcbiAgICB9XG4gIH1cbiAgLy8gZGUtYWJzb2x1dGl6ZSB0aGUgcGF0aFxuICBpZiAoc3lzdGVtLmlzV2luZG93cygpKSB7XG4gICAgaWYgKHJlbW90ZVBhdGguaW5kZXhvZignOi8vJykgPT09IDEpIHtcbiAgICAgIHJlbW90ZVBhdGggPSByZW1vdGVQYXRoLnNsaWNlKDQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAocmVtb3RlUGF0aC5pbmRleE9mKCcvJykgPT09IDApIHtcbiAgICAgIHJlbW90ZVBhdGggPSByZW1vdGVQYXRoLnNsaWNlKDEpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChyZW1vdGVQYXRoLnN0YXJ0c1dpdGgoYXBwTmFtZSkpIHtcbiAgICBsZXQgZmluZFBhdGggPSBiYXNlUGF0aDtcbiAgICBpZiAoIXRoaXMub3B0cy5wbGF0Zm9ybVZlcnNpb24gfHwgdXRpbC5jb21wYXJlVmVyc2lvbnModGhpcy5vcHRzLnBsYXRmb3JtVmVyc2lvbiwgJz49JywgJzguMCcpKSB7XG4gICAgICAvLyB0aGUgLmFwcCBmaWxlIGFwcGVhcnMgaW4gL0NvbnRhaW5lcnMvRGF0YSBhbmQgL0NvbnRhaW5lcnMvQnVuZGxlIGJvdGguIFdlIG9ubHkgd2FudCAvQnVuZGxlXG4gICAgICBmaW5kUGF0aCA9IHBhdGgucmVzb2x2ZShiYXNlUGF0aCwgJ0NvbnRhaW5lcnMnLCAnQnVuZGxlJyk7XG4gICAgfVxuICAgIGZpbmRQYXRoID0gZmluZFBhdGgucmVwbGFjZSgvXFxzL2csICdcXFxcICcpO1xuXG4gICAgbGV0IHsgc3Rkb3V0IH0gPSBhd2FpdCBleGVjKCdmaW5kJywgW2ZpbmRQYXRoLCAnLW5hbWUnLCBhcHBOYW1lXSk7XG4gICAgbGV0IGFwcFJvb3QgPSBzdGRvdXQucmVwbGFjZSgvXFxuJC8sICcnKTtcbiAgICBsZXQgc3ViUGF0aCA9IHJlbW90ZVBhdGguc3Vic3RyaW5nKGFwcE5hbWUubGVuZ3RoICsgMSk7XG4gICAgbGV0IGZ1bGxQYXRoID0gcGF0aC5yZXNvbHZlKGFwcFJvb3QsIHN1YlBhdGgpO1xuICAgIGxvZy5kZWJ1ZyhgRmluZGluZyBhcHAtcmVsYXRpdmUgZmlsZTogJyR7ZnVsbFBhdGh9J2ApO1xuICAgIHJldHVybiBmdWxsUGF0aDtcbiAgfVxuXG4gIGxldCBmdWxsUGF0aCA9IHBhdGgucmVzb2x2ZShiYXNlUGF0aCwgcmVtb3RlUGF0aCk7XG4gIGxvZy5kZWJ1ZyhgRmluZGluZyBzaW0tcmVsYXRpdmUgZmlsZTogJHtmdWxsUGF0aH1gKTtcbiAgcmV0dXJuIGZ1bGxQYXRoO1xufTtcblxuY29tbWFuZHMucHVsbEZvbGRlciA9IGFzeW5jIGZ1bmN0aW9uIHB1bGxGb2xkZXIgKHJlbW90ZVBhdGgpIHtcbiAgaWYgKCFyZW1vdGVQYXRoLmVuZHNXaXRoKCcvJykpIHtcbiAgICByZW1vdGVQYXRoID0gYCR7cmVtb3RlUGF0aH0vYDtcbiAgfVxuICByZXR1cm4gdGhpcy5pc1NpbXVsYXRvcigpXG4gICAgPyBhd2FpdCBwdWxsRnJvbVNpbXVsYXRvcih0aGlzLm9wdHMuZGV2aWNlLCByZW1vdGVQYXRoLCBmYWxzZSlcbiAgICA6IGF3YWl0IHB1bGxGcm9tUmVhbERldmljZSh0aGlzLm9wdHMuZGV2aWNlLCByZW1vdGVQYXRoLCBmYWxzZSk7XG59O1xuXG5leHBvcnQgeyBjb21tYW5kcywgLyogZm9yIHRlc3RpbmcgKi8gZ2V0QXZhaWxhYmxlQnVuZGxlSWRzLFxuICAvKiBmb3IgdGVzdGluZyAqLyBwYXJzZUNvbnRhaW5lclBhdGggfTtcbmV4cG9ydCBkZWZhdWx0IGNvbW1hbmRzO1xuIl0sImZpbGUiOiJsaWIvY29tbWFuZHMvZmlsZS1tb3ZlbWVudC5qcyIsInNvdXJjZVJvb3QiOiIuLi8uLi8uLiJ9
