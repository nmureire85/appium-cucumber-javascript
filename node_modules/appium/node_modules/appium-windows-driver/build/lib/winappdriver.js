"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.DEFAULT_WAD_PORT = exports.DEFAULT_WAD_HOST = exports.WinAppDriver = void 0;

require("source-map-support/register");

var _events = _interopRequireDefault(require("events"));

var _appiumBaseDriver = require("appium-base-driver");

var _logger = _interopRequireDefault(require("./logger"));

var _teen_process = require("teen_process");

var _installer = require("./installer");

var _asyncbox = require("asyncbox");

var _child_process = _interopRequireDefault(require("child_process"));

var _bluebird = _interopRequireDefault(require("bluebird"));

const REQUIRED_PARAMS = [];
const DEFAULT_WAD_HOST = '127.0.0.1';
exports.DEFAULT_WAD_HOST = DEFAULT_WAD_HOST;
const DEFAULT_WAD_PORT = 4724;
exports.DEFAULT_WAD_PORT = DEFAULT_WAD_PORT;
const DEFAULT_CREATE_SESSION_TIMEOUT_MS = 20000;

class WinAppDriver extends _events.default.EventEmitter {
  constructor(opts = {}) {
    const {
      host,
      port,
      createSessionTimeout
    } = opts;
    super();

    for (let req of REQUIRED_PARAMS) {
      if (!opts || !opts[req]) {
        throw new Error(`Option '${req}' is required!`);
      }

      this[req] = opts[req];
    }

    this.proxyHost = host || DEFAULT_WAD_HOST;
    this.proxyPort = port || DEFAULT_WAD_PORT;
    this.createSessionTimeout = createSessionTimeout || DEFAULT_CREATE_SESSION_TIMEOUT_MS;
    this.proc = null;
    this.state = WinAppDriver.STATE_STOPPED;
    this.jwproxy = new _appiumBaseDriver.JWProxy({
      server: this.proxyHost,
      port: this.proxyPort
    });
  }

  async start() {
    if (!(await (0, _installer.isWADInstalled)())) {
      throw new Error('Could not verify WinAppDriver install; re-run install');
    }

    if (!(await (0, _installer.isWADChecksumOk)())) {
      _logger.default.warn('WinAppDriver exists, but the checksum did not match. Was it replaced manually?');
    }

    this.changeState(WinAppDriver.STATE_STARTING);
    let args = [this.proxyPort + '/wd/hub'];

    const startDetector = stdout => stdout.includes('listening for requests');

    let processIsAlive = false;

    try {
      await this.killAll();
      this.proc = new _teen_process.SubProcess(_installer.WAD_INSTALL_PATH, args, {
        encoding: 'ucs2'
      });
      processIsAlive = true;

      for (let stream of ['STDOUT', 'STDERR']) {
        this.proc.on(`lines-${stream.toLowerCase()}`, lines => {
          for (let l of lines) {
            _logger.default.info(`[${stream}] ${l.trim()}`);
          }
        });
      }

      this.proc.on('exit', (code, signal) => {
        processIsAlive = false;

        if (this.state !== WinAppDriver.STATE_STOPPED && this.state !== WinAppDriver.STATE_STOPPING) {
          let msg = `WinAppDriver exited unexpectedly with code ${code}, ` + `signal ${signal}`;

          _logger.default.error(msg);

          this.changeState(WinAppDriver.STATE_STOPPED);
        }
      });

      _logger.default.info(`Spawning WinAppDriver with: ${args.join(' ')}`);

      await this.proc.start(startDetector);
      await this.waitForOnline();
    } catch (e) {
      this.emit(WinAppDriver.EVENT_ERROR, e);

      if (processIsAlive) {
        await this.proc.stop();
      }

      _logger.default.errorAndThrow(e);
    }
  }

  sessionId() {
    if (this.state !== WinAppDriver.STATE_ONLINE) {
      return null;
    }

    return this.jwproxy.sessionId;
  }

  async waitForOnline() {
    let winappdriverStopped = false;
    await (0, _asyncbox.retryInterval)(20, 200, async () => {
      if ([WinAppDriver.STATE_STOPPED, WinAppDriver.STATE_ONLINE].indexOf(this.state) >= 0) {
        winappdriverStopped = this.state === WinAppDriver.STATE_STOPPED;
        return;
      }

      if (await this.getStatus()) {
        this.changeState(WinAppDriver.STATE_ONLINE);
      }
    });

    if (winappdriverStopped) {
      throw new Error('WinAppDriver crashed during startup.');
    }
  }

  async getStatus() {
    const resBlock = await this.jwproxy.proxy('/status', 'GET');

    if (resBlock[0].statusCode === 200) {
      _logger.default.info(`Status call returned 200. we're online and ready to run tests`);

      return true;
    }

    return false;
  }

  async startSession(caps) {
    const createSessionTimeout = caps.createSessionTimeout || this.createSessionTimeout;

    _logger.default.debug(`Starting WinAppDriver session. Will timeout in '${createSessionTimeout}' ms.`);

    this.proxyReqRes = this.jwproxy.proxyReqRes.bind(this.jwproxy);
    let retryIteration = 0;
    let lastError;

    const condFn = async () => {
      lastError = null;

      try {
        retryIteration++;
        await this.jwproxy.command('/session', 'POST', {
          desiredCapabilities: caps
        });
        return true;
      } catch (error) {
        lastError = error;

        _logger.default.warn(`Could not start WinAppDriver session error = '${error.message}', attempt = '${retryIteration}' from '${this.createSessionRetry}'`);

        return false;
      }
    };

    try {
      await (0, _asyncbox.waitForCondition)(condFn, {
        waitMs: createSessionTimeout,
        intervalMs: 500
      });
    } catch (timeoutError) {
      _logger.default.debug(`timeoutError was ${timeoutError.message}`);

      if (lastError) {
        throw lastError;
      }

      throw new Error(`Could not start WinAppDriver session within ${createSessionTimeout} ms.`);
    }
  }

  async stop(emitStates = true) {
    if (emitStates) {
      this.changeState(WinAppDriver.STATE_STOPPING);
    }

    try {
      if (this.proc) {
        await this.proc.stop();
      }

      if (emitStates) {
        this.changeState(WinAppDriver.STATE_STOPPED);
      }
    } catch (e) {
      _logger.default.error(e);
    }
  }

  changeState(state) {
    this.state = state;

    _logger.default.debug(`WinAppDriver changed state to '${state}'`);

    this.emit(WinAppDriver.EVENT_CHANGED, {
      state
    });
  }

  async sendCommand(url, method, body) {
    return await this.jwproxy.command(url, method, body);
  }

  async proxyReq(req, res) {
    return await this.jwproxy.proxyReqRes(req, res);
  }

  async killAll() {
    let cmd;
    cmd = 'FOR /F "usebackq tokens=5" %a in (`netstat -nao ^| ' + 'findstr /R /C:"' + this.proxyPort + ' "`) do (' + 'FOR /F "usebackq" %b in (`TASKLIST /FI "PID eq %a" ^| ' + 'findstr /I winappdriver.exe`) do (IF NOT %b=="" TASKKILL ' + '/F /PID %a))';

    _logger.default.info(`Killing any old WinAppDrivers on same port, running: ${cmd}`);

    try {
      await _bluebird.default.promisify(_child_process.default.exec)(cmd);

      _logger.default.info('Successfully cleaned up old WinAppDrivers');
    } catch (err) {
      _logger.default.info('No old WinAppDrivers seemed to exist');
    }
  }

  async deleteSession() {
    _logger.default.debug('Deleting WinAppDriver server session');

    try {
      await this.jwproxy.command('/', 'DELETE');
    } catch (err) {
      _logger.default.warn(`Did not get confirmation WinAppDriver deleteSession worked; ` + `Error was: ${err}`);
    }
  }

}

exports.WinAppDriver = WinAppDriver;
WinAppDriver.EVENT_ERROR = 'winappdriver_error';
WinAppDriver.EVENT_CHANGED = 'stateChanged';
WinAppDriver.STATE_STOPPED = 'stopped';
WinAppDriver.STATE_STARTING = 'starting';
WinAppDriver.STATE_ONLINE = 'online';
WinAppDriver.STATE_STOPPING = 'stopping';
var _default = WinAppDriver;
exports.default = _default;require('source-map-support').install();


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi93aW5hcHBkcml2ZXIuanMiXSwibmFtZXMiOlsiUkVRVUlSRURfUEFSQU1TIiwiREVGQVVMVF9XQURfSE9TVCIsIkRFRkFVTFRfV0FEX1BPUlQiLCJERUZBVUxUX0NSRUFURV9TRVNTSU9OX1RJTUVPVVRfTVMiLCJXaW5BcHBEcml2ZXIiLCJldmVudHMiLCJFdmVudEVtaXR0ZXIiLCJjb25zdHJ1Y3RvciIsIm9wdHMiLCJob3N0IiwicG9ydCIsImNyZWF0ZVNlc3Npb25UaW1lb3V0IiwicmVxIiwiRXJyb3IiLCJwcm94eUhvc3QiLCJwcm94eVBvcnQiLCJwcm9jIiwic3RhdGUiLCJTVEFURV9TVE9QUEVEIiwiandwcm94eSIsIkpXUHJveHkiLCJzZXJ2ZXIiLCJzdGFydCIsImxvZyIsIndhcm4iLCJjaGFuZ2VTdGF0ZSIsIlNUQVRFX1NUQVJUSU5HIiwiYXJncyIsInN0YXJ0RGV0ZWN0b3IiLCJzdGRvdXQiLCJpbmNsdWRlcyIsInByb2Nlc3NJc0FsaXZlIiwia2lsbEFsbCIsIlN1YlByb2Nlc3MiLCJXQURfSU5TVEFMTF9QQVRIIiwiZW5jb2RpbmciLCJzdHJlYW0iLCJvbiIsInRvTG93ZXJDYXNlIiwibGluZXMiLCJsIiwiaW5mbyIsInRyaW0iLCJjb2RlIiwic2lnbmFsIiwiU1RBVEVfU1RPUFBJTkciLCJtc2ciLCJlcnJvciIsImpvaW4iLCJ3YWl0Rm9yT25saW5lIiwiZSIsImVtaXQiLCJFVkVOVF9FUlJPUiIsInN0b3AiLCJlcnJvckFuZFRocm93Iiwic2Vzc2lvbklkIiwiU1RBVEVfT05MSU5FIiwid2luYXBwZHJpdmVyU3RvcHBlZCIsImluZGV4T2YiLCJnZXRTdGF0dXMiLCJyZXNCbG9jayIsInByb3h5Iiwic3RhdHVzQ29kZSIsInN0YXJ0U2Vzc2lvbiIsImNhcHMiLCJkZWJ1ZyIsInByb3h5UmVxUmVzIiwiYmluZCIsInJldHJ5SXRlcmF0aW9uIiwibGFzdEVycm9yIiwiY29uZEZuIiwiY29tbWFuZCIsImRlc2lyZWRDYXBhYmlsaXRpZXMiLCJtZXNzYWdlIiwiY3JlYXRlU2Vzc2lvblJldHJ5Iiwid2FpdE1zIiwiaW50ZXJ2YWxNcyIsInRpbWVvdXRFcnJvciIsImVtaXRTdGF0ZXMiLCJFVkVOVF9DSEFOR0VEIiwic2VuZENvbW1hbmQiLCJ1cmwiLCJtZXRob2QiLCJib2R5IiwicHJveHlSZXEiLCJyZXMiLCJjbWQiLCJCIiwicHJvbWlzaWZ5IiwiY3AiLCJleGVjIiwiZXJyIiwiZGVsZXRlU2Vzc2lvbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFFQSxNQUFNQSxlQUFlLEdBQUcsRUFBeEI7QUFDQSxNQUFNQyxnQkFBZ0IsR0FBRyxXQUF6Qjs7QUFDQSxNQUFNQyxnQkFBZ0IsR0FBRyxJQUF6Qjs7QUFDQSxNQUFNQyxpQ0FBaUMsR0FBRyxLQUExQzs7QUFFQSxNQUFNQyxZQUFOLFNBQTJCQyxnQkFBT0MsWUFBbEMsQ0FBK0M7QUFDN0NDLEVBQUFBLFdBQVcsQ0FBRUMsSUFBSSxHQUFHLEVBQVQsRUFBYTtBQUN0QixVQUFNO0FBQUNDLE1BQUFBLElBQUQ7QUFBT0MsTUFBQUEsSUFBUDtBQUFhQyxNQUFBQTtBQUFiLFFBQXFDSCxJQUEzQztBQUNBOztBQUVBLFNBQUssSUFBSUksR0FBVCxJQUFnQlosZUFBaEIsRUFBaUM7QUFDL0IsVUFBSSxDQUFDUSxJQUFELElBQVMsQ0FBQ0EsSUFBSSxDQUFDSSxHQUFELENBQWxCLEVBQXlCO0FBQ3ZCLGNBQU0sSUFBSUMsS0FBSixDQUFXLFdBQVVELEdBQUksZ0JBQXpCLENBQU47QUFDRDs7QUFDRCxXQUFLQSxHQUFMLElBQVlKLElBQUksQ0FBQ0ksR0FBRCxDQUFoQjtBQUNEOztBQUVELFNBQUtFLFNBQUwsR0FBaUJMLElBQUksSUFBSVIsZ0JBQXpCO0FBQ0EsU0FBS2MsU0FBTCxHQUFpQkwsSUFBSSxJQUFJUixnQkFBekI7QUFDQSxTQUFLUyxvQkFBTCxHQUE0QkEsb0JBQW9CLElBQUlSLGlDQUFwRDtB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STtBQUVGLFlBQU9DLGtCQUFFQyxTQUFGLENBQVlDLHVCQUFHQyxJQUFmLENBQUQsQ0FBdUJKLEdBQXZCLENBQU47O0FBQ0EvRCxzQkFBSWtCLElBQUosQ0FBUywyQ0FBVDtBQUNELEtBSkQsQ0FJRSxPQUFPa0QsR0FBUCxFQUFZO0FBQ1pwRSxzQkFBSWtCLElBQUosQ0FBUyxzQ0FBVDtBQUNEO0FBQ0Y7O0FBRUQsUUFBTW1ELGFBQU4sR0FBdUI7QUFDckJyRSxvQkFBSTBDLEtBQUosQ0FBVSxzQ0FBVjs7QUFHQSxRQUFJO0FBQ0YsWUFBTSxLQUFLOUMsT0FBTCxDQUFhb0QsT0FBYixDQUFxQixHQUFyQixFQUEwQixRQUExQixDQUFOO0FBQ0QsS0FGRCxDQUVFLE9BQU9vQixHQUFQLEVBQVk7QUFDWnBFLHNCQUFJQyxJQUFKLENBQVUsOERBQUQsR0FDTixjQUFhbUUsR0FBSSxFQURwQjtBQUVEO0FBQ0Y7O0FBck40Qzs7O0FBd04vQ3ZGLFlBQVksQ0FBQ2dELFdBQWIsR0FBMkIsb0JBQTNCO0FBQ0FoRCxZQUFZLENBQUMyRSxhQUFiLEdBQTZCLGNBQTdCO0FBQ0EzRSxZQUFZLENBQUNjLGFBQWIsR0FBNkIsU0FBN0I7QUFDQWQsWUFBWSxDQUFDc0IsY0FBYixHQUE4QixVQUE5QjtBQUNBdEIsWUFBWSxDQUFDb0QsWUFBYixHQUE0QixRQUE1QjtBQUNBcEQsWUFBWSxDQUFDeUMsY0FBYixHQUE4QixVQUE5QjtlQUdlekMsWSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBldmVudHMgZnJvbSAnZXZlbnRzJztcbmltcG9ydCB7IEpXUHJveHkgfSBmcm9tICdhcHBpdW0tYmFzZS1kcml2ZXInO1xuaW1wb3J0IGxvZyBmcm9tICcuL2xvZ2dlcic7XG5pbXBvcnQgeyBTdWJQcm9jZXNzIH0gZnJvbSAndGVlbl9wcm9jZXNzJztcbmltcG9ydCB7IFdBRF9JTlNUQUxMX1BBVEgsIGlzV0FEQ2hlY2tzdW1PaywgaXNXQURJbnN0YWxsZWQgfSBmcm9tICcuL2luc3RhbGxlcic7XG5pbXBvcnQgeyByZXRyeUludGVydmFsLCB3YWl0Rm9yQ29uZGl0aW9uIH0gZnJvbSAnYXN5bmNib3gnO1xuaW1wb3J0IGNwIGZyb20gJ2NoaWxkX3Byb2Nlc3MnO1xuaW1wb3J0IEIgZnJvbSAnYmx1ZWJpcmQnO1xuXG5jb25zdCBSRVFVSVJFRF9QQVJBTVMgPSBbXTsgLy8gWFhZRCAxLTUtMjAxODogcmVtb3ZlZCBhcHAgZnJvbSByZXF1aXJlZCBwYXJhbXMgYmVjYXVzZSB5b3UgY2FuIGFsdGVybmF0aXZlbHkgdXNlIGFwcFRvcExldmVsV2luZG93XG5jb25zdCBERUZBVUxUX1dBRF9IT1NUID0gJzEyNy4wLjAuMSc7XG5jb25zdCBERUZBVUxUX1dBRF9QT1JUID0gNDcyNDsgLy8gc2hvdWxkIGJlIG5vbi00NzIzIHRvIGF2b2lkIGNvbmZsaWN0IG9uIHRoZSBzYW1lIGJveDtcbmNvbnN0IERFRkFVTFRfQ1JFQVRFX1NFU1NJT05fVElNRU9VVF9NUyA9IDIwMDAwOyAvLyByZXRyeSBzdGFydCBzZXNzaW9uIGNyZWF0aW9uIGR1cmluZyB0aGUgdGltZW91dCBpbiBtaWxsaXNlY29uZHNcblxuY2xhc3MgV2luQXBwRHJpdmVyIGV4dGVuZHMgZXZlbnRzLkV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yIChvcHRzID0ge30pIHtcbiAgICBjb25zdCB7aG9zdCwgcG9ydCwgY3JlYXRlU2Vzc2lvblRpbWVvdXR9ID0gb3B0cztcbiAgICBzdXBlcigpO1xuXG4gICAgZm9yIChsZXQgcmVxIG9mIFJFUVVJUkVEX1BBUkFNUykge1xuICAgICAgaWYgKCFvcHRzIHx8ICFvcHRzW3JlcV0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBPcHRpb24gJyR7cmVxfScgaXMgcmVxdWlyZWQhYCk7XG4gICAgICB9XG4gICAgICB0aGlzW3JlcV0gPSBvcHRzW3JlcV07XG4gICAgfVxuXG4gICAgdGhpcy5wcm94eUhvc3QgPSBob3N0IHx8IERFRkFVTFRfV0FEX0hPU1Q7XG4gICAgdGhpcy5wcm94eVBvcnQgPSBwb3J0IHx8IERFRkFVTFRfV0FEX1BPUlQ7XG4gICAgdGhpcy5jcmVhdGVTZXNzaW9uVGltZW91dCA9IGNyZWF0ZVNlc3Npb25UaW1lb3V0IHx8IERFRkFVTFRfQ1JFQVRFX1NFU1NJT05fVElNRU9VVF9NUztcbiAgICB0aGlzLnByb2MgPSBudWxsO1xuICAgIHRoaXMuc3RhdGUgPSBXaW5BcHBEcml2ZXIuU1RBVEVfU1RPUFBFRDtcbiAgICB0aGlzLmp3cHJveHkgPSBuZXcgSldQcm94eSh7c2VydmVyOiB0aGlzLnByb3h5SG9zdCwgcG9ydDogdGhpcy5wcm94eVBvcnR9KTtcbiAgfVxuXG4gIGFzeW5jIHN0YXJ0ICgpIHtcbiAgICBpZiAoIWF3YWl0IGlzV0FESW5zdGFsbGVkKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IHZlcmlmeSBXaW5BcHBEcml2ZXIgaW5zdGFsbDsgcmUtcnVuIGluc3RhbGwnKTtcbiAgICB9XG4gICAgaWYgKCFhd2FpdCBpc1dBRENoZWNrc3VtT2soKSkge1xuICAgICAgbG9nLndhcm4oJ1dpbkFwcERyaXZlciBleGlzdHMsIGJ1dCB0aGUgY2hlY2tzdW0gZGlkIG5vdCBtYXRjaC4gV2FzIGl0IHJlcGxhY2VkIG1hbnVhbGx5PycpO1xuICAgIH1cblxuICAgIHRoaXMuY2hhbmdlU3RhdGUoV2luQXBwRHJpdmVyLlNUQVRFX1NUQVJUSU5HKTtcblxuICAgIC8vIFhYWFlEIFRPRE86IHdvdWxkIGJlIGJldHRlciBpZiBXaW5BcHBEcml2ZXIgZGlkbid0IHJlcXVpcmUgcGFzc2luZyBpbiAvd2QvaHViIGFzIGEgcGFyYW1cbiAgICBsZXQgYXJncyA9IFt0aGlzLnByb3h5UG9ydCArICcvd2QvaHViJ107XG5cbiAgICBjb25zdCBzdGFydERldGVjdG9yID0gKHN0ZG91dCkgPT4gc3Rkb3V0LmluY2x1ZGVzKCdsaXN0ZW5pbmcgZm9yIHJlcXVlc3RzJyk7XG5cbiAgICBsZXQgcHJvY2Vzc0lzQWxpdmUgPSBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5raWxsQWxsKCk7XG5cbiAgICAgIC8vIHNldCB1cCBvdXIgc3VicHJvY2VzcyBvYmplY3RcbiAgICAgIHRoaXMucHJvYyA9IG5ldyBTdWJQcm9jZXNzKFdBRF9JTlNUQUxMX1BBVEgsIGFyZ3MsIHtcbiAgICAgICAgZW5jb2Rpbmc6ICd1Y3MyJ1xuICAgICAgfSk7XG4gICAgICBwcm9jZXNzSXNBbGl2ZSA9IHRydWU7XG5cbiAgICAgIC8vIGhhbmRsZSBsb2cgb3V0cHV0XG4gICAgICBmb3IgKGxldCBzdHJlYW0gb2YgWydTVERPVVQnLCAnU1RERVJSJ10pIHtcbiAgICAgICAgdGhpcy5wcm9jLm9uKGBsaW5lcy0ke3N0cmVhbS50b0xvd2VyQ2FzZSgpfWAsIChsaW5lcykgPT4ge1xuICAgICAgICAgIGZvciAobGV0IGwgb2YgbGluZXMpIHtcbiAgICAgICAgICAgIGxvZy5pbmZvKGBbJHtzdHJlYW19XSAke2wudHJpbSgpfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGhhbmRsZSBvdXQtb2YtYm91bmQgZXhpdCBieSBzaW1wbHkgZW1pdHRpbmcgYSBzdG9wcGVkIHN0YXRlXG4gICAgICB0aGlzLnByb2Mub24oJ2V4aXQnLCAoY29kZSwgc2lnbmFsKSA9PiB7XG4gICAgICAgIHByb2Nlc3NJc0FsaXZlID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBXaW5BcHBEcml2ZXIuU1RBVEVfU1RPUFBFRCAmJlxuICAgICAgICAgICAgdGhpcy5zdGF0ZSAhPT0gV2luQXBwRHJpdmVyLlNUQVRFX1NUT1BQSU5HKSB7XG4gICAgICAgICAgbGV0IG1zZyA9IGBXaW5BcHBEcml2ZXIgZXhpdGVkIHVuZXhwZWN0ZWRseSB3aXRoIGNvZGUgJHtjb2RlfSwgYCArXG4gICAgICAgICAgICAgICAgICAgIGBzaWduYWwgJHtzaWduYWx9YDtcbiAgICAgICAgICBsb2cuZXJyb3IobXNnKTtcbiAgICAgICAgICB0aGlzLmNoYW5nZVN0YXRlKFdpbkFwcERyaXZlci5TVEFURV9TVE9QUEVEKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBsb2cuaW5mbyhgU3Bhd25pbmcgV2luQXBwRHJpdmVyIHdpdGg6ICR7YXJncy5qb2luKCcgJyl9YCk7XG5cbiAgICAgIC8vIHN0YXJ0IHN1YnByb2MgYW5kIHdhaXQgZm9yIHN0YXJ0RGV0ZWN0b3JcbiAgICAgIGF3YWl0IHRoaXMucHJvYy5zdGFydChzdGFydERldGVjdG9yKTtcbiAgICAgIGF3YWl0IHRoaXMud2FpdEZvck9ubGluZSgpO1xuXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhpcy5lbWl0KFdpbkFwcERyaXZlci5FVkVOVF9FUlJPUiwgZSk7XG4gICAgICAvLyBqdXN0IGJlY2F1c2Ugd2UgaGFkIGFuIGVycm9yIGRvZXNuJ3QgbWVhbiB0aGUgV2luQXBwRHJpdmVyIHByb2Nlc3NcbiAgICAgIC8vIGZpbmlzaGVkOyB3ZSBzaG91bGQgY2xlYW4gdXAgaWYgbmVjZXNzYXJ5XG4gICAgICBpZiAocHJvY2Vzc0lzQWxpdmUpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5wcm9jLnN0b3AoKTtcbiAgICAgIH1cbiAgICAgIGxvZy5lcnJvckFuZFRocm93KGUpO1xuICAgIH1cbiAgfVxuXG4gIHNlc3Npb25JZCAoKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUgIT09IFdpbkFwcERyaXZlci5TVEFURV9PTkxJTkUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmp3cHJveHkuc2Vzc2lvbklkO1xuICB9XG5cbiAgYXN5bmMgd2FpdEZvck9ubGluZSAoKSB7XG5cbiAgICAvLyB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSBXQUQgaGFzbid0IGNyYXNoZWRcbiAgICBsZXQgd2luYXBwZHJpdmVyU3RvcHBlZCA9IGZhbHNlO1xuICAgIGF3YWl0IHJldHJ5SW50ZXJ2YWwoMjAsIDIwMCwgYXN5bmMgKCkgPT4ge1xuICAgICAgaWYgKFtXaW5BcHBEcml2ZXIuU1RBVEVfU1RPUFBFRCwgV2luQXBwRHJpdmVyLlNUQVRFX09OTElORV0uaW5kZXhPZih0aGlzLnN0YXRlKSA+PSAwKSB7XG4gICAgICAgIC8vIHdlIGFyZSBlaXRoZXIgc3RvcHBlZCwgc3RvcHBpbmcsIG9yIHdlJ3JlIG9ubGluZVxuICAgICAgICB3aW5hcHBkcml2ZXJTdG9wcGVkID0gdGhpcy5zdGF0ZSA9PT0gV2luQXBwRHJpdmVyLlNUQVRFX1NUT1BQRUQ7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGF3YWl0IHRoaXMuZ2V0U3RhdHVzKCkpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VTdGF0ZShXaW5BcHBEcml2ZXIuU1RBVEVfT05MSU5FKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmICh3aW5hcHBkcml2ZXJTdG9wcGVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dpbkFwcERyaXZlciBjcmFzaGVkIGR1cmluZyBzdGFydHVwLicpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGdldFN0YXR1cyAoKSB7XG4gICAgY29uc3QgcmVzQmxvY2sgPSBhd2FpdCB0aGlzLmp3cHJveHkucHJveHkoJy9zdGF0dXMnLCAnR0VUJyk7XG4gICAgaWYgKHJlc0Jsb2NrWzBdLnN0YXR1c0NvZGUgPT09IDIwMCkge1xuICAgICAgbG9nLmluZm8oYFN0YXR1cyBjYWxsIHJldHVybmVkIDIwMC4gd2UncmUgb25saW5lIGFuZCByZWFkeSB0byBydW4gdGVzdHNgKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBhc3luYyBzdGFydFNlc3Npb24gKGNhcHMpIHtcblxuICAgIGNvbnN0IGNyZWF0ZVNlc3Npb25UaW1lb3V0ID0gY2Fwcy5jcmVhdGVTZXNzaW9uVGltZW91dCB8fCB0aGlzLmNyZWF0ZVNlc3Npb25UaW1lb3V0O1xuICAgIGxvZy5kZWJ1ZyhgU3RhcnRpbmcgV2luQXBwRHJpdmVyIHNlc3Npb24uIFdpbGwgdGltZW91dCBpbiAnJHtjcmVhdGVTZXNzaW9uVGltZW91dH0nIG1zLmApO1xuICAgIHRoaXMucHJveHlSZXFSZXMgPSB0aGlzLmp3cHJveHkucHJveHlSZXFSZXMuYmluZCh0aGlzLmp3cHJveHkpO1xuICAgIGxldCByZXRyeUl0ZXJhdGlvbiA9IDA7XG4gICAgbGV0IGxhc3RFcnJvcjtcblxuICAgIGNvbnN0IGNvbmRGbiA9IGFzeW5jICgpID0+IHtcbiAgICAgIGxhc3RFcnJvciA9IG51bGw7XG4gICAgICB0cnkge1xuICAgICAgICByZXRyeUl0ZXJhdGlvbisrO1xuICAgICAgICBhd2FpdCB0aGlzLmp3cHJveHkuY29tbWFuZCgnL3Nlc3Npb24nLCAnUE9TVCcsIHtkZXNpcmVkQ2FwYWJpbGl0aWVzOiBjYXBzfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbGFzdEVycm9yID0gZXJyb3I7XG4gICAgICAgIGxvZy53YXJuKGBDb3VsZCBub3Qgc3RhcnQgV2luQXBwRHJpdmVyIHNlc3Npb24gZXJyb3IgPSAnJHtlcnJvci5tZXNzYWdlfScsIGF0dGVtcHQgPSAnJHtyZXRyeUl0ZXJhdGlvbn0nIGZyb20gJyR7dGhpcy5jcmVhdGVTZXNzaW9uUmV0cnl9J2ApO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRyeSB7XG4gICAgICBhd2FpdCB3YWl0Rm9yQ29uZGl0aW9uKGNvbmRGbiwge1xuICAgICAgICB3YWl0TXM6IGNyZWF0ZVNlc3Npb25UaW1lb3V0LFxuICAgICAgICBpbnRlcnZhbE1zOiA1MDBcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKHRpbWVvdXRFcnJvcikge1xuICAgICAgbG9nLmRlYnVnKGB0aW1lb3V0RXJyb3Igd2FzICR7dGltZW91dEVycm9yLm1lc3NhZ2V9YCk7XG4gICAgICBpZiAobGFzdEVycm9yKSB7XG4gICAgICAgIHRocm93IChsYXN0RXJyb3IpO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3Qgc3RhcnQgV2luQXBwRHJpdmVyIHNlc3Npb24gd2l0aGluICR7Y3JlYXRlU2Vzc2lvblRpbWVvdXR9IG1zLmApO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIHN0b3AgKGVtaXRTdGF0ZXMgPSB0cnVlKSB7XG4gICAgaWYgKGVtaXRTdGF0ZXMpIHtcbiAgICAgIHRoaXMuY2hhbmdlU3RhdGUoV2luQXBwRHJpdmVyLlNUQVRFX1NUT1BQSU5HKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0aGlzLnByb2MpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5wcm9jLnN0b3AoKTtcbiAgICAgIH1cbiAgICAgIGlmIChlbWl0U3RhdGVzKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlU3RhdGUoV2luQXBwRHJpdmVyLlNUQVRFX1NUT1BQRUQpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGxvZy5lcnJvcihlKTtcbiAgICB9XG4gIH1cblxuICBjaGFuZ2VTdGF0ZSAoc3RhdGUpIHtcbiAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgbG9nLmRlYnVnKGBXaW5BcHBEcml2ZXIgY2hhbmdlZCBzdGF0ZSB0byAnJHtzdGF0ZX0nYCk7XG4gICAgdGhpcy5lbWl0KFdpbkFwcERyaXZlci5FVkVOVF9DSEFOR0VELCB7c3RhdGV9KTtcbiAgfVxuXG4gIGFzeW5jIHNlbmRDb21tYW5kICh1cmwsIG1ldGhvZCwgYm9keSkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmp3cHJveHkuY29tbWFuZCh1cmwsIG1ldGhvZCwgYm9keSk7XG4gIH1cblxuICBhc3luYyBwcm94eVJlcSAocmVxLCByZXMpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5qd3Byb3h5LnByb3h5UmVxUmVzKHJlcSwgcmVzKTtcbiAgfVxuXG4gIGFzeW5jIGtpbGxBbGwgKCkge1xuICAgIGxldCBjbWQ7XG4gICAgLy8ganMgaGludCBjYW5ub3QgaGFuZGxlIGJhY2t0aWNrcywgZXZlbiBlc2NhcGVkLCB3aXRoaW4gdGVtcGxhdGUgbGl0ZXJhbHNcbiAgICBjbWQgPSAnRk9SIC9GIFwidXNlYmFja3EgdG9rZW5zPTVcIiAlYSBpbiAoYG5ldHN0YXQgLW5hbyBefCAnICtcbiAgICAgICAgICAnZmluZHN0ciAvUiAvQzpcIicgKyB0aGlzLnByb3h5UG9ydCArICcgXCJgKSBkbyAoJyArXG4gICAgICAgICAgJ0ZPUiAvRiBcInVzZWJhY2txXCIgJWIgaW4gKGBUQVNLTElTVCAvRkkgXCJQSUQgZXEgJWFcIiBefCAnICtcbiAgICAgICAgICAnZmluZHN0ciAvSSB3aW5hcHBkcml2ZXIuZXhlYCkgZG8gKElGIE5PVCAlYj09XCJcIiBUQVNLS0lMTCAnICtcbiAgICAgICAgICAnL0YgL1BJRCAlYSkpJztcbiAgICBsb2cuaW5mbyhgS2lsbGluZyBhbnkgb2xkIFdpbkFwcERyaXZlcnMgb24gc2FtZSBwb3J0LCBydW5uaW5nOiAke2NtZH1gKTtcbiAgICB0cnkge1xuICAgICAgLy8gdXNlIGNwLmV4ZWMgaW5zdGVhZCBvZiB0ZWVuIHByb2Nlc3MgYmVjYXVzZSBvZiBjcmF6eSB3aW5kb3dzIHF1b3RpbmdcbiAgICAgIGF3YWl0IChCLnByb21pc2lmeShjcC5leGVjKSkoY21kKTtcbiAgICAgIGxvZy5pbmZvKCdTdWNjZXNzZnVsbHkgY2xlYW5lZCB1cCBvbGQgV2luQXBwRHJpdmVycycpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgbG9nLmluZm8oJ05vIG9sZCBXaW5BcHBEcml2ZXJzIHNlZW1lZCB0byBleGlzdCcpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGRlbGV0ZVNlc3Npb24gKCkge1xuICAgIGxvZy5kZWJ1ZygnRGVsZXRpbmcgV2luQXBwRHJpdmVyIHNlcnZlciBzZXNzaW9uJyk7XG4gICAgLy8gcmVseSBvbiBqd3Byb3h5J3MgaW50ZWxsaWdlbmNlIHRvIGtub3cgd2hhdCB3ZSdyZSB0YWxraW5nIGFib3V0IGFuZFxuICAgIC8vIGRlbGV0ZSB0aGUgY3VycmVudCBzZXNzaW9uXG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuandwcm94eS5jb21tYW5kKCcvJywgJ0RFTEVURScpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgbG9nLndhcm4oYERpZCBub3QgZ2V0IGNvbmZpcm1hdGlvbiBXaW5BcHBEcml2ZXIgZGVsZXRlU2Vzc2lvbiB3b3JrZWQ7IGAgK1xuICAgICAgICBgRXJyb3Igd2FzOiAke2Vycn1gKTtcbiAgICB9XG4gIH1cbn1cblxuV2luQXBwRHJpdmVyLkVWRU5UX0VSUk9SID0gJ3dpbmFwcGRyaXZlcl9lcnJvcic7XG5XaW5BcHBEcml2ZXIuRVZFTlRfQ0hBTkdFRCA9ICdzdGF0ZUNoYW5nZWQnO1xuV2luQXBwRHJpdmVyLlNUQVRFX1NUT1BQRUQgPSAnc3RvcHBlZCc7XG5XaW5BcHBEcml2ZXIuU1RBVEVfU1RBUlRJTkcgPSAnc3RhcnRpbmcnO1xuV2luQXBwRHJpdmVyLlNUQVRFX09OTElORSA9ICdvbmxpbmUnO1xuV2luQXBwRHJpdmVyLlNUQVRFX1NUT1BQSU5HID0gJ3N0b3BwaW5nJztcblxuZXhwb3J0IHsgV2luQXBwRHJpdmVyLCBERUZBVUxUX1dBRF9IT1NULCBERUZBVUxUX1dBRF9QT1JUIH07XG5leHBvcnQgZGVmYXVsdCBXaW5BcHBEcml2ZXI7XG4iXSwiZmlsZSI6ImxpYi93aW5hcHBkcml2ZXIuanMiLCJzb3VyY2VSb290IjoiLi4vLi4ifQ==
