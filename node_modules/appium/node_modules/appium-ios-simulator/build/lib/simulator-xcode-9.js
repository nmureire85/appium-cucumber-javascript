"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("source-map-support/register");

var _simulatorXcode = _interopRequireDefault(require("./simulator-xcode-8"));

var _lodash = _interopRequireDefault(require("lodash"));

var _path = _interopRequireDefault(require("path"));

var _appiumSupport = require("appium-support");

var _asyncLock = _interopRequireDefault(require("async-lock"));

var _logger = _interopRequireDefault(require("./logger"));

var _asyncbox = require("asyncbox");

var _utils = require("./utils.js");

const SIMULATOR_SHUTDOWN_TIMEOUT = 15 * 1000;
const startupLock = new _asyncLock.default();
const preferencesPlistGuard = new _asyncLock.default();
const ENROLLMENT_NOTIFICATION_RECEIVER = 'com.apple.BiometricKit.enrollmentChanged';

class SimulatorXcode9 extends _simulatorXcode.default {
  constructor(udid, xcodeVersion) {
    super(udid, xcodeVersion);
  }

  async run(opts = {}) {
    opts = _lodash.default.cloneDeep(opts);

    _lodash.default.defaultsDeep(opts, {
      devicePreferences: {},
      isHeadless: false,
      startupTimeout: this.startupTimeout
    });

    if (opts.scaleFactor) {
      opts.devicePreferences.SimulatorWindowLastScale = parseFloat(opts.scaleFactor);
    }

    const commonPreferences = {
      RotateWindowWhenSignaledByGuest: true
    };

    if (_lodash.default.isBoolean(opts.connectHardwareKeyboard)) {
      opts.devicePreferences.ConnectHardwareKeyboard = opts.connectHardwareKeyboard;
      commonPreferences.ConnectHardwareKeyboard = opts.connectHardwareKeyboard;
    }

    if (!_lodash.default.isEmpty(opts.devicePreferences) || !_lodash.default.isEmpty(commonPreferences)) {
      await this.updatePreferences(opts.devicePreferences, commonPreferences);
    }

    const waitForShutdown = async (waitMs = SIMULATOR_SHUTDOWN_TIMEOUT) => {
      try {
        await (0, _asyncbox.waitForCondition)(async () => {
          const {
            state
          } = await this.stat();
          return state === 'Shutdown';
        }, {
          waitMs,
          intervalMs: 500
        });
      } catch (err) {
        throw new Error(`Simulator is not in 'Shutdown' state after ${waitMs}ms`);
      }
    };

    const timer = new _appiumSupport.timing.Timer().start();
    const shouldWaitForBoot = await startupLock.acquire(this.uiClientBundleId, async () => {
      const {
        state: serverState
      } = await this.stat();
      const isServerRunning = serverState === 'Booted';
      const uiClientPid = await this.getUIClientPid();

      if (opts.isHeadless) {
        if (isServerRunning && !uiClientPid) {
          _logger.default.info(`Simulator with UDID '${this.udid}' is already booted in headless mode.`);

          return false;
        }

        if (await this.killUIClient({
          pid: uiClientPid
        })) {
          _logger.default.info(`Detected the Simulator UI client was running and killed it. Verifying the current Simulator state...`);
        }

        try {
          await waitForShutdown(3000);
        } catch (e) {
          const {
            state
          } = await this.stat();

          if (state !== 'Booted') {
            throw new Error(`Simulator with UDID '${this.udid}' cannot be transitioned to headless mode. ` + `The recent state is '${state}'`);
          }

          return false;
        }

        _logger.default.info(`Booting Simulator with UDID '${this.udid}' in headless mode. All UI-related capabilities are going to be ignored`);

        await this.boot();
      } else {
        if (isServerRunning && uiClientPid) {
          _logger.default.info(`Both Simulator with UDID '${this.udid}' and the UI client are currently running`);

          return false;
        }

        if (!['Shutdown', 'Booted'].includes(serverState)) {
          if (serverState !== 'Shutting Down') {
            _logger.default.info(`Simulator '${this.udid}' is in '${serverState}' state. Trying to shutdown...`);

            try {
              await this.shutdown();
            } catch (err) {
              _logger.default.warn(`Error on Simulator shutdown: ${err.message}`);
            }
          }

          await waitForShutdown();
        }

        await this.launchWindow(uiClientPid, opts);
      }

      return true;
    });

    if (shouldWaitForBoot) {
      await this.waitForBoot(opts.startupTimeout);

      _logger.default.info(`Simulator with UDID ${this.udid} booted in ${timer.getDuration().asSeconds.toFixed(3)}s`);
    }
  }

  async launchWindow(isUiClientRunning, opts = {}) {
    await this.boot();

    if (!isUiClientRunning) {
      await this.startUIClient(opts);
    }
  }

  async boot() {
    _logger.default.info(`Booting Simulator with UDID '${this.udid}'...`);

    try {
      await (0, _asyncbox.retryInterval)(3, 2000, async () => {
        try {
          await this.simctl.bootDevice();
        } catch (e) {
          if (!_lodash.default.includes(e.stderr, 'Unable to boot device in current state: Booted')) {
            throw e;
          }

          _logger.default.debug(`Simulator with UDID '${this.udid}' is already in Booted state`);
        }
      });
    } catch (err) {
      _logger.default.warn(err.stderr || err.message);
    }
  }

  verifyDevicePreferences(prefs = {}) {
    if (_lodash.default.isEmpty(prefs)) {
      return;
    }

    if (!_lodash.default.isUndefined(prefs.SimulatorWindowLastScale)) {
      if (!_lodash.default.isNumber(prefs.SimulatorWindowLastScale) || prefs.SimulatorWindowLastScale <= 0) {
        _logger.default.errorAndThrow(`SimulatorWindowLastScale is expected to be a positive float value. ` + `'${prefs.SimulatorWindowLastScale}' is assigned instead.`);
      }
    }

    if (!_lodash.default.isUndefined(prefs.SimulatorWindowCenter)) {
      const verificationPattern = /{-?\d+(\.\d+)?,-?\d+(\.\d+)?}/;

      if (!_lodash.default.isString(prefs.SimulatorWindowCenter) || !verificationPattern.test(prefs.SimulatorWindowCenter)) {
        _logger.default.errorAndThrow(`SimulatorWindowCenter is expected to match "{floatXPosition,floatYPosition}" format (without spaces). ` + `'${prefs.SimulatorWindowCenter}' is assigned instead.`);
      }
    }

    if (!_lodash.default.isUndefined(prefs.SimulatorWindowOrientation)) {
      const acceptableValues = ['Portrait', 'LandscapeLeft', 'PortraitUpsideDown', 'LandscapeRight'];

      if (acceptableValues.indexOf(prefs.SimulatorWindowOrientation) === -1) {
        _logger.default.errorAndThrow(`SimulatorWindowOrientation is expected to be one of ${acceptableValues}. ` + `'${prefs.SimulatorWindowOrientation}' is assigned instead.`);
      }
    }

    if (!_lodash.default.isUndefined(prefs.SimulatorWindowRotationAngle)) {
      if (!_lodash.default.isNumber(prefs.SimulatorWindowRotationAngle)) {
        _logger.default.errorAndThrow(`SimulatorWindowRotationAngle is expected to be a valid number. ` + `'${prefs.SimulatorWindowRotationAngle}' is assigned instead.`);
      }
    }
  }

  async updatePreferences(devicePrefs = {}, commonPrefs = {}) {
    if (!_lodash.default.isEmpty(devicePrefs)) {
      _logger.default.debug(`Setting preferences of ${this.udid} Simulator to ${JSON.stringify(devicePrefs)}`);
    }

    if (!_lodash.default.isEmpty(commonPrefs)) {
      _logger.default.debug(`Setting common Simulator preferences to ${JSON.stringify(commonPrefs)}`);
    }

    const homeFolderPath = process.env.HOME;

    if (!homeFolderPath) {
      _logger.default.warn(`Cannot get the path to HOME folder from the process environment. ` + `Ignoring Simulator preferences update.`);

      return false;
    }

    this.verifyDevicePreferences(devicePrefs);

    const plistPath = _path.default.resolve(homeFolderPath, 'Library', 'Preferences', 'com.apple.iphonesimulator.plist');

    if (!(await _appiumSupport.fs.hasAccess(plistPath))) {
      _logger.default.warn(`Simulator preferences file '${plistPath}' is not accessible. ` + `Ignoring Simulator preferences update.`);

      return false;
    }

    let newPrefs = {};

    if (!_lodash.default.isEmpty(devicePrefs)) {
      newPrefs.DevicePreferences = {
        [this.udid.toUpperCase()]: devicePrefs
      };
    }

    newPrefs = _lodash.default.merge(newPrefs, commonPrefs);
    return await preferencesPlistGuard.acquire(SimulatorXcode9.name, async () => {
      try {
        const currentPlistContent = await _appiumSupport.plist.parsePlistFile(plistPath);
        await _appiumSupport.plist.updatePlistFile(plistPath, _lodash.default.merge(currentPlistContent, newPrefs), true);

        _logger.default.debug(`Updated ${this.udid} Simulator preferences at '${plistPath}' with ${JSON.stringify(newPrefs)}`);

        return true;
      } catch (e) {
        _logger.default.warn(`Cannot update ${this.udid} Simulator preferences at '${plistPath}'. ` + `Try to delete the file manually in order to reset it. Original error: ${e.message}`);

        return false;
      }
    });
  }

  async shutdown() {
    const {
      state
    } = await this.stat();

    if (state === 'Shutdown') {
      return;
    }

    await (0, _asyncbox.retryInterval)(5, 500, this.simctl.shutdownDevice.bind(this.simctl));
  }

  async clean() {
    _logger.default.info(`Cleaning simulator ${this.udid}`);

    await this.simctl.eraseDevice(10000);
  }

  async _activateWindow() {
    let selfName;
    let selfSdk;
    let bootedDevicesCount = 0;

    for (const [sdk, deviceArr] of _lodash.default.toPairs(await this.simctl.getDevices())) {
      for (const {
        state,
        udid,
        name
      } of deviceArr) {
        if (state === 'Booted') {
          bootedDevicesCount++;
        }

        if (!selfName && udid === this.udid) {
          selfSdk = sdk;
          selfName = name;
        }
      }
    }

    if (bootedDevicesCount < 2) {
      return await super._activateWindow();
    }

    return `
      tell application "System Events"
        tell process "Simulator"
          set frontmost to false
          set frontmost to true
          click (menu item 1 where (its name contains "${selfName} " and its name contains "${selfSdk}")) of menu 1 of menu bar item "Window" of menu bar 1
        end tell
      end tell
    `;
  }

  async isBiometricEnrolled() {
    const {
      stdout
    } = await this.simctl.spawnProcess(['notifyutil', '-g', ENROLLMENT_NOTIFICATION_RECEIVER]);
    const match = new RegExp(`${_lodash.default.escapeRegExp(ENROLLMENT_NOTIFICATION_RECEIVER)}\\s+([01])`).exec(stdout);

    if (!match) {
      throw new Error(`Cannot parse biometric enrollment state from '${stdout}'`);
    }

    _logger.default.info(`Current biometric enrolled state for ${this.udid} Simulator: ${match[1]}`);

    return match[1] === '1';
  }

  async enrollBiometric(isEnabled = true) {
    _logger.default.debug(`Setting biometric enrolled state for ${this.udid} Simulator to '${isEnabled ? 'enabled' : 'disabled'}'`);

    await this.simctl.spawnProcess(['notifyutil', '-s', ENROLLMENT_NOTIFICATION_RECEIVER, isEnabled ? '1' : '0']);
    await this.simctl.spawnProcess(['notifyutil', '-p', ENROLLMENT_NOTIFICATION_RECEIVER]);

    if ((await this.isBiometricEnrolled()) !== isEnabled) {
      throw new Error(`Cannot set biometric enrolled state for ${this.udid} Simulator to '${isEnabled ? 'enabled' : 'disabled'}'`);
    }
  }

  async sendBiometricMatch(shouldMatch = true, biometricName = 'touchId') {
    const domainComponent = (0, _utils.toBiometricDomainComponent)(biometricName);
    const domain = `com.apple.BiometricKit_Sim.${domainComponent}.${shouldMatch ? '' : 'no'}match`;
    await this.simctl.spawnProcess(['notifyutil', '-p', domain]);

    _logger.default.info(`Sent notification ${domain} to ${shouldMatch ? 'match' : 'not match'} ${biometricName} biometric ` + `for ${this.udid} Simulator`);
  }

  async getLaunchDaemonsRoot() {
    const devRoot = await (0, _utils.getDeveloperRoot)();
    return _path.default.resolve(devRoot, 'Platforms/iPhoneOS.platform/Developer/Library/CoreSimulator/Profiles/Runtimes/iOS.simruntime/Contents/Resources/RuntimeRoot/System/Library/LaunchDaemons');
  }

}

var _default = SimulatorXcode9;
exports.default = _default;require('source-map-support').install();


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9zaW11bGF0b3IteGNvZGUtOS5qcyJdLCJuYW1lcyI6WyJTSU1VTEFUT1JfU0hVVERPV05fVElNRU9VVCIsInN0YXJ0dXBMb2NrIiwiQXN5bmNMb2NrIiwicHJlZmVyZW5jZXNQbGlzdEd1YXJkIiwiRU5ST0xMTUVOVF9OT1RJRklDQVRJT05fUkVDRUlWRVIiLCJTaW11bGF0b3JYY29kZTkiLCJTaW11bGF0b3JYY29kZTgiLCJjb25zdHJ1Y3RvciIsInVkaWQiLCJ4Y29kZVZlcnNpb24iLCJydW4iLCJvcHRzIiwiXyIsImNsb25lRGVlcCIsImRlZmF1bHRzRGVlcCIsImRldmljZVByZWZlcmVuY2VzIiwiaXNIZWFkbGVzcyIsInN0YXJ0dXBUaW1lb3V0Iiwic2NhbGVGYWN0b3IiLCJTaW11bGF0b3JXaW5kb3dMYXN0U2NhbGUiLCJwYXJzZUZsb2F0IiwiY29tbW9uUHJlZmVyZW5jZXMiLCJSb3RhdGVXaW5kb3dXaGVuU2lnbmFsZWRCeUd1ZXN0IiwiaXNCb29sZWFuIiwiY29ubmVjdEhhcmR3YXJlS2V5Ym9hcmQiLCJDb25uZWN0SGFyZHdhcmVLZXlib2FyZCIsImlzRW1wdHkiLCJ1cGRhdGVQcmVmZXJlbmNlcyIsIndhaXRGb3JTaHV0ZG93biIsIndhaXRNcyIsInN0YXRlIiwic3RhdCIsImludGVydmFsTXMiLCJlcnIiLCJFcnJvciIsInRpbWVyIiwidGltaW5nIiwiVGltZXIiLCJzdGFydCIsInNob3VsZFdhaXRGb3JCb290IiwiYWNxdWlyZSIsInVpQ2xpZW50QnVuZGxlSWQiLCJzZXJ2ZXJTdGF0ZSIsImlzU2VydmVyUnVubmluZyIsInVpQ2xpZW50UGlkIiwiZ2V0VUlDbGllbnRQaWQiLCJsb2ciLCJpbmZvIiwia2lsbFVJQ2xpZW50IiwicGlkIiwiZSIsImJvb3QiLCJpbmNsdWRlcyIsInNodXRkb3duIiwid2FybiIsIm1lc3NhZ2UiLCJsYXVuY2hXaW5kb3ciLCJ3YWl0Rm9yQm9vdCIsImdldER1cmF0aW9uIiwiYXNTZWNvbmRzIiwidG9GaXhlZCIsImlzVWlDbGllbnRSdW5uaW5nIiwic3RhcnRVSUNsaWVudCIsInNpbWN0bCIsImJvb3REZXZpY2UiLCJzdGRlcnIiLCJkZWJ1ZyIsInZlcmlmeURldmljZVByZWZlcmVuY2VzIiwicHJlZnMiLCJpc1VuZGVmaW5lZCIsImlzTnVtYmVyIiwiZXJyb3JBbmRUaHJvdyIsIlNpbXVsYXRvcldpbmRvd0NlbnRlciIsInZlcmlmaWNhdGlvblBhdHRlcm4iLCJpc1N0cmluZyIsInRlc3QiLCJTaW11bGF0b3JXaW5kb3dPcmllbnRhdGlvbiIsImFjY2VwdGFibGVWYWx1ZXMiLCJpbmRleE9mIiwiU2ltdWxhdG9yV2luZG93Um90YXRpb25BbmdsZSIsImRldmljZVByZWZzIiwiY29tbW9uUHJlZnMiLCJKU09OIiwic3RyaW5naWZ5IiwiaG9tZUZvbGRlclBhdGgiLCJwcm9jZXNzIiwiZW52IiwiSE9NRSIsInBsaXN0UGF0aCIsInBhdGgiLCJyZXNvbHZlIiwiZnMiLCJoYXNBY2Nlc3MiLCJuZXdQcmVmcyIsIkRldmljZVByZWZlcmVuY2VzIiwidG9VcHBlckNhc2UiLCJtZXJnZSIsIm5hbWUiLCJjdXJyZW50UGxpc3RDb250ZW50IiwicGxpc3QiLCJwYXJzZVBsaXN0RmlsZSIsInVwZGF0ZVBsaXN0RmlsZSIsInNodXRkb3duRGV2aWNlIiwiYmluZCIsImNsZWFuIiwiZXJhc2VEZXZpY2UiLCJfYWN0aXZhdGVXaW5kb3ciLCJzZWxmTmFtZSIsInNlbGZTZGsiLCJib290ZWREZXZpY2VzQ291bnQiLCJzZGsiLCJkZXZpY2VBcnIiLCJ0b1BhaXJzIiwiZ2V0RGV2aWNlcyIsImlzQmlvbWV0cmljRW5yb2xsZWQiLCJzdGRvdXQiLCJzcGF3blByb2Nlc3MiLCJtYXRjaCIsIlJlZ0V4cCIsImVzY2FwZVJlZ0V4cCIsImV4ZWMiLCJlbnJvbGxCaW9tZXRyaWMiLCJpc0VuYWJsZWQiLCJzZW5kQmlvbWV0cmljTWF0Y2giLCJzaG91bGRNYXRjaCIsImJpb21ldHJpY05hbWUiLCJkb21haW5Db21wb25lbnQiLCJk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WS9CNUgsZSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBTaW11bGF0b3JYY29kZTggZnJvbSAnLi9zaW11bGF0b3IteGNvZGUtOCc7XG5pbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgeyBmcywgcGxpc3QsIHRpbWluZyB9IGZyb20gJ2FwcGl1bS1zdXBwb3J0JztcbmltcG9ydCBBc3luY0xvY2sgZnJvbSAnYXN5bmMtbG9jayc7XG5pbXBvcnQgbG9nIGZyb20gJy4vbG9nZ2VyJztcbmltcG9ydCB7IHdhaXRGb3JDb25kaXRpb24sIHJldHJ5SW50ZXJ2YWwgfSBmcm9tICdhc3luY2JveCc7XG5pbXBvcnQgeyB0b0Jpb21ldHJpY0RvbWFpbkNvbXBvbmVudCwgZ2V0RGV2ZWxvcGVyUm9vdCB9IGZyb20gJy4vdXRpbHMuanMnO1xuXG5jb25zdCBTSU1VTEFUT1JfU0hVVERPV05fVElNRU9VVCA9IDE1ICogMTAwMDtcbmNvbnN0IHN0YXJ0dXBMb2NrID0gbmV3IEFzeW5jTG9jaygpO1xuY29uc3QgcHJlZmVyZW5jZXNQbGlzdEd1YXJkID0gbmV3IEFzeW5jTG9jaygpO1xuY29uc3QgRU5ST0xMTUVOVF9OT1RJRklDQVRJT05fUkVDRUlWRVIgPSAnY29tLmFwcGxlLkJpb21ldHJpY0tpdC5lbnJvbGxtZW50Q2hhbmdlZCc7XG5cbmNsYXNzIFNpbXVsYXRvclhjb2RlOSBleHRlbmRzIFNpbXVsYXRvclhjb2RlOCB7XG4gIGNvbnN0cnVjdG9yICh1ZGlkLCB4Y29kZVZlcnNpb24pIHtcbiAgICBzdXBlcih1ZGlkLCB4Y29kZVZlcnNpb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IERldmljZVByZWZlcmVuY2VzXG4gICAqIEBwcm9wZXJ0eSB7P251bWJlcn0gU2ltdWxhdG9yRXh0ZXJuYWxEaXNwbGF5IC0gVEJELiBFeGFtcGxlIHZhbHVlOiAyLjExNFxuICAgKiBAcHJvcGVydHkgez9zdHJpbmd9IENocm9tZVRpbnQgLSBUQkQuIEV4YW1wbGUgdmFsdWU6ICcnXG4gICAqIEBwcm9wZXJ0eSB7P251bWJlcn0gU2ltdWxhdG9yV2luZG93TGFzdFNjYWxlIC0gU2NhbGUgdmFsdWUgZm9yIHRoZSBwYXJ0aWN1bGFyIFNpbXVsYXRvciB3aW5kb3cuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMS4wIG1lYW5zIDEwMCUgc2NhbGUuXG4gICAqIEBwcm9wZXJ0eSB7P3N0cmluZ30gU2ltdWxhdG9yV2luZG93T3JpZW50YXRpb24gLSBTaW11bGF0b3Igd2luZG93IG9yaWVudGF0aW9uLiBQb3NzaWJsZSB2YWx1ZXMgYXJlOlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1BvcnRyYWl0JywgJ0xhbmRzY2FwZUxlZnQnLCAnUG9ydHJhaXRVcHNpZGVEb3duJyBhbmQgJ0xhbmRzY2FwZVJpZ2h0Jy5cbiAgICogQHByb3BlcnR5IHs/bnVtYmVyfSBTaW11bGF0b3JXaW5kb3dSb3RhdGlvbkFuZ2xlIC0gV2luZG93IHJvdGF0aW9uIGFuZ2xlLiBUaGlzIHZhbHVlIGlzIGV4cGVjdGVkIHRvIGJlIGluIHN5bmNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2l0aCBfU2ltdWxhdG9yV2luZG93T3JpZW50YXRpb25fLiBUaGUgY29ycmVzcG9uZGluZyB2YWx1ZXMgYXJlOlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLCA5MCwgMTgwIGFuZCAyNzAuXG4gICAqIEBwcm9wZXJ0eSB7P3N0cmluZ30gU2ltdWxhdG9yV2luZG93Q2VudGVyIC0gVGhlIGNvb3JkaW5hdGVzIG9mIFNpbXVsYXRvcidzIHdpbmRvdyBjZW50ZXIgaW4gcGl4ZWxzLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciBleGFtcGxlICd7LTEyOTQuNSwgNzc1LjV9Jy5cbiAgICogQHByb3BlcnR5IHs/Ym9vbGVhbn0gQ29ubmVjdEhhcmR3YXJlS2V5Ym9hcmQgLSBFcXVhbHMgdG8gMSBpZiBoYXJkd2FyZSBrZXlib2FyZCBzaG91bGQgYmUgY29ubmVjdGVkLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE90aGVyd2lzZSAwLlxuICAgKi9cblxuICAvKipcbiAgICogQHR5cGVkZWYge09iamVjdH0gQ29tbW9uUHJlZmVyZW5jZXNcbiAgICogQHByb3BlcnR5IHtib29sZWFufSBDb25uZWN0SGFyZHdhcmVLZXlib2FyZCAtIFdoZXRoZXIgdG8gY29ubmVjdCBoYXJkd2FyZSBrZXlib2FyZFxuICAgKi9cblxuICAvKipcbiAgICogQHR5cGVkZWYge09iamVjdH0gUnVuT3B0aW9uc1xuICAgKiBAcHJvcGVydHkge3N0cmluZ30gc2NhbGVGYWN0b3I6IEFueSBwb3NpdGl2ZSBmbG9hdCB2YWx1ZS4gMS4wIG1lYW5zIDE6MSBzY2FsZS5cbiAgICogRGVmaW5lcyB0aGUgd2luZG93IHNjYWxlIHZhbHVlIGZvciB0aGUgVUkgY2xpZW50IHdpbmRvdyBmb3IgdGhlIGN1cnJlbnQgU2ltdWxhdG9yLlxuICAgKiBFcXVhbHMgdG8gYG51bGxgIGJ5IGRlZmF1bHQsIHdoaWNoIGtlZXBzIHRoZSBjdXJyZW50IHNjYWxlIHVuY2hhbmdlZC5cbiAgICogQHByb3BlcnR5IHtib29sZWFufSBjb25uZWN0SGFyZHdhcmVLZXlib2FyZDogd2hldGhlciB0byBjb25uZWN0IHRoZSBoYXJkd2FyZSBrZXlib2FyZCB0byB0aGVcbiAgICogU2ltdWxhdG9yIFVJIGNsaWVudC4gRXF1YWxzIHRvIGBmYWxzZWAgYnkgZGVmYXVsdC5cbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IHN0YXJ0dXBUaW1lb3V0OiBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHdhaXQgdW50aWwgU2ltdWxhdG9yIGJvb3RpbmdcbiAgICogcHJvY2VzcyBpcyBjb21wbGV0ZWQuIFRoZSBkZWZhdWx0IHRpbWVvdXQgd2lsbCBiZSB1c2VkIGlmIG5vdCBzZXQgZXhwbGljaXRseS5cbiAgICogQHByb3BlcnR5IHtib29sZWFufSBpc0hlYWRsZXNzOiB3aGV0aGVyIHRvIHN0YXJ0IHRoZSBTaW11bGF0b3IgaW4gaGVhZGxlc3MgbW9kZSAod2l0aCBVSVxuICAgKiBjbGllbnQgaW52aXNpYmxlKS4gYGZhbHNlYCBieSBkZWZhdWx0LlxuICAgKiBAcHJvcGVydHkgez9ib29sZWFufSB0cmFjZVBvaW50ZXIgW2ZhbHNlXSAtIFdoZXRoZXIgdG8gaGlnaGxpZ2h0IHRvdWNoZXMgb24gU2ltdWxhdG9yXG4gICAqIHNjcmVlbi4gVGhpcyBpcyBoZWxwZnVsIHdoaWxlIGRlYnVnZ2luZyBhdXRvbWF0ZWQgdGVzdHMgb3Igd2hpbGUgb2JzZXJ2aW5nIHRoZSBhdXRvbWF0aW9uXG4gICAqIHJlY29yZGluZ3MuXG4gICAqIEBwcm9wZXJ0eSB7RGV2aWNlUHJlZmVyZW5jZXN9IGRldmljZVByZWZlcmVuY2VzOiBwcmVmZXJlbmNlcyBvZiB0aGUgbmV3bHkgY3JlYXRlZCBTaW11bGF0b3JcbiAgICogZGV2aWNlXG4gICAqL1xuXG4gIC8qKlxuICAgKiBFeGVjdXRlcyBnaXZlbiBTaW11bGF0b3Igd2l0aCBvcHRpb25zLiBUaGUgU2ltdWxhdG9yIHdpbGwgbm90IGJlIHJlc3RhcnRlZCBpZlxuICAgKiBpdCBpcyBhbHJlYWR5IHJ1bm5pbmcgYW5kIHRoZSBjdXJyZW50IFVJIHN0YXRlIG1hdGNoZXMgdG8gYGlzSGVhZGxlc3NgIG9wdGlvbi5cbiAgICogQG92ZXJyaWRlXG4gICAqXG4gICAqIEBwYXJhbSB7UnVuT3B0aW9uc30gb3B0cyAtIE9uZSBvciBtb3JlIG9mIGF2YWlsYWJsZSBTaW11bGF0b3Igb3B0aW9uc1xuICAgKi9cbiAgYXN5bmMgcnVuIChvcHRzID0ge30pIHtcbiAgICBvcHRzID0gXy5jbG9uZURlZXAob3B0cyk7XG4gICAgXy5kZWZhdWx0c0RlZXAob3B0cywge1xuICAgICAgZGV2aWNlUHJlZmVyZW5jZXM6IHt9LFxuICAgICAgaXNIZWFkbGVzczogZmFsc2UsXG4gICAgICBzdGFydHVwVGltZW91dDogdGhpcy5zdGFydHVwVGltZW91dCxcbiAgICB9KTtcbiAgICBpZiAob3B0cy5zY2FsZUZhY3Rvcikge1xuICAgICAgb3B0cy5kZXZpY2VQcmVmZXJlbmNlcy5TaW11bGF0b3JXaW5kb3dMYXN0U2NhbGUgPSBwYXJzZUZsb2F0KG9wdHMuc2NhbGVGYWN0b3IpO1xuICAgIH1cbiAgICAvLyBUaGlzIG9wdGlvbiBpcyBuZWNlc3NhcnkgdG8gbWFrZSB0aGUgU2ltdWxhdG9yIHdpbmRvdyBmb2xsb3dcbiAgICAvLyB0aGUgYWN0dWFsIFhDVUlEZXZpY2Ugb3JpZW50YXRpb25cbiAgICBjb25zdCBjb21tb25QcmVmZXJlbmNlcyA9IHtcbiAgICAgIFJvdGF0ZVdpbmRvd1doZW5TaWduYWxlZEJ5R3Vlc3Q6IHRydWVcbiAgICB9O1xuICAgIGlmIChfLmlzQm9vbGVhbihvcHRzLmNvbm5lY3RIYXJkd2FyZUtleWJvYXJkKSkge1xuICAgICAgb3B0cy5kZXZpY2VQcmVmZXJlbmNlcy5Db25uZWN0SGFyZHdhcmVLZXlib2FyZCA9IG9wdHMuY29ubmVjdEhhcmR3YXJlS2V5Ym9hcmQ7XG4gICAgICBjb21tb25QcmVmZXJlbmNlcy5Db25uZWN0SGFyZHdhcmVLZXlib2FyZCA9IG9wdHMuY29ubmVjdEhhcmR3YXJlS2V5Ym9hcmQ7XG4gICAgfVxuICAgIGlmICghXy5pc0VtcHR5KG9wdHMuZGV2aWNlUHJlZmVyZW5jZXMpIHx8ICFfLmlzRW1wdHkoY29tbW9uUHJlZmVyZW5jZXMpKSB7XG4gICAgICBhd2FpdCB0aGlzLnVwZGF0ZVByZWZlcmVuY2VzKG9wdHMuZGV2aWNlUHJlZmVyZW5jZXMsIGNvbW1vblByZWZlcmVuY2VzKTtcbiAgICB9XG4gICAgY29uc3Qgd2FpdEZvclNodXRkb3duID0gYXN5bmMgKHdhaXRNcyA9IFNJTVVMQVRPUl9TSFVURE9XTl9USU1FT1VUKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCB3YWl0Rm9yQ29uZGl0aW9uKGFzeW5jICgpID0+IHtcbiAgICAgICAgICBjb25zdCB7c3RhdGV9ID0gYXdhaXQgdGhpcy5zdGF0KCk7XG4gICAgICAgICAgcmV0dXJuIHN0YXRlID09PSAnU2h1dGRvd24nO1xuICAgICAgICB9LCB7d2FpdE1zLCBpbnRlcnZhbE1zOiA1MDB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNpbXVsYXRvciBpcyBub3QgaW4gJ1NodXRkb3duJyBzdGF0ZSBhZnRlciAke3dhaXRNc31tc2ApO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgdGltZXIgPSBuZXcgdGltaW5nLlRpbWVyKCkuc3RhcnQoKTtcbiAgICBjb25zdCBzaG91bGRXYWl0Rm9yQm9vdCA9IGF3YWl0IHN0YXJ0dXBMb2NrLmFjcXVpcmUodGhpcy51aUNsaWVudEJ1bmRsZUlkLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB7c3RhdGU6IHNlcnZlclN0YXRlfSA9IGF3YWl0IHRoaXMuc3RhdCgpO1xuICAgICAgY29uc3QgaXNTZXJ2ZXJSdW5uaW5nID0gc2VydmVyU3RhdGUgPT09ICdCb290ZWQnO1xuICAgICAgY29uc3QgdWlDbGllbnRQaWQgPSBhd2FpdCB0aGlzLmdldFVJQ2xpZW50UGlkKCk7XG4gICAgICBpZiAob3B0cy5pc0hlYWRsZXNzKSB7XG4gICAgICAgIGlmIChpc1NlcnZlclJ1bm5pbmcgJiYgIXVpQ2xpZW50UGlkKSB7XG4gICAgICAgICAgbG9nLmluZm8oYFNpbXVsYXRvciB3aXRoIFVESUQgJyR7dGhpcy51ZGlkfScgaXMgYWxyZWFkeSBib290ZWQgaW4gaGVhZGxlc3MgbW9kZS5gKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF3YWl0IHRoaXMua2lsbFVJQ2xpZW50KHtwaWQ6IHVpQ2xpZW50UGlkfSkpIHtcbiAgICAgICAgICBsb2cuaW5mbyhgRGV0ZWN0ZWQgdGhlIFNpbXVsYXRvciBVSSBjbGllbnQgd2FzIHJ1bm5pbmcgYW5kIGtpbGxlZCBpdC4gVmVyaWZ5aW5nIHRoZSBjdXJyZW50IFNpbXVsYXRvciBzdGF0ZS4uLmApO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gU3RvcHBpbmcgdGhlIFVJIGNsaWVudCBraWxscyBhbGwgcnVubmluZyBzZXJ2ZXJzIGZvciBzb21lIGVhcmx5IFhDb2RlIHZlcnNpb25zLiBUaGlzIGlzIGEga25vd24gYnVnXG4gICAgICAgICAgYXdhaXQgd2FpdEZvclNodXRkb3duKDMwMDApO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgY29uc3Qge3N0YXRlfSA9IGF3YWl0IHRoaXMuc3RhdCgpO1xuICAgICAgICAgIGlmIChzdGF0ZSAhPT0gJ0Jvb3RlZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgU2ltdWxhdG9yIHdpdGggVURJRCAnJHt0aGlzLnVkaWR9JyBjYW5ub3QgYmUgdHJhbnNpdGlvbmVkIHRvIGhlYWRsZXNzIG1vZGUuIGAgK1xuICAgICAgICAgICAgICBgVGhlIHJlY2VudCBzdGF0ZSBpcyAnJHtzdGF0ZX0nYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBsb2cuaW5mbyhgQm9vdGluZyBTaW11bGF0b3Igd2l0aCBVRElEICcke3RoaXMudWRpZH0nIGluIGhlYWRsZXNzIG1vZGUuIEFsbCBVSS1yZWxhdGVkIGNhcGFiaWxpdGllcyBhcmUgZ29pbmcgdG8gYmUgaWdub3JlZGApO1xuICAgICAgICBhd2FpdCB0aGlzLmJvb3QoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc1NlcnZlclJ1bm5pbmcgJiYgdWlDbGllbnRQaWQpIHtcbiAgICAgICAgICBsb2cuaW5mbyhgQm90aCBTaW11bGF0b3Igd2l0aCBVRElEICcke3RoaXMudWRpZH0nIGFuZCB0aGUgVUkgY2xpZW50IGFyZSBjdXJyZW50bHkgcnVubmluZ2ApO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIVsnU2h1dGRvd24nLCAnQm9vdGVkJ10uaW5jbHVkZXMoc2VydmVyU3RhdGUpKSB7XG4gICAgICAgICAgaWYgKHNlcnZlclN0YXRlICE9PSAnU2h1dHRpbmcgRG93bicpIHtcbiAgICAgICAgICAgIGxvZy5pbmZvKGBTaW11bGF0b3IgJyR7dGhpcy51ZGlkfScgaXMgaW4gJyR7c2VydmVyU3RhdGV9JyBzdGF0ZS4gVHJ5aW5nIHRvIHNodXRkb3duLi4uYCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBhd2FpdCB0aGlzLnNodXRkb3duKCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgbG9nLndhcm4oYEVycm9yIG9uIFNpbXVsYXRvciBzaHV0ZG93bjogJHtlcnIubWVzc2FnZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYXdhaXQgd2FpdEZvclNodXRkb3duKCk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy5sYXVuY2hXaW5kb3codWlDbGllbnRQaWQsIG9wdHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG5cbiAgICBpZiAoc2hvdWxkV2FpdEZvckJvb3QpIHtcbiAgICAgIGF3YWl0IHRoaXMud2FpdEZvckJvb3Qob3B0cy5zdGFydHVwVGltZW91dCk7XG4gICAgICBsb2cuaW5mbyhgU2ltdWxhdG9yIHdpdGggVURJRCAke3RoaXMudWRpZH0gYm9vdGVkIGluICR7dGltZXIuZ2V0RHVyYXRpb24oKS5hc1NlY29uZHMudG9GaXhlZCgzKX1zYCk7XG4gICAgfVxuICB9XG5cbiAgLyoqKlxuICAgKiBCb290cyBzaW11bGF0b3IgYW5kIG9wZW5zIHNpbXVsYXRvcnMgVUkgQ2xpZW50IGlmIG5vdCBhbHJlYWR5IG9wZW5lZC5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBpc1VpQ2xpZW50UnVubmluZyAtIHByb2Nlc3MgaWQgb2Ygc2ltdWxhdG9yIFVJIGNsaWVudC5cbiAgICogQHBhcmFtIHtSdW5PcHRpb25zfSBvcHRzIC0gYXJndW1lbnRzIHRvIHN0YXJ0IHNpbXVsYXRvciBVSSBjbGllbnQgd2l0aC5cbiAgICovXG4gIGFzeW5jIGxhdW5jaFdpbmRvdyAoaXNVaUNsaWVudFJ1bm5pbmcsIG9wdHMgPSB7fSkge1xuICAgIGF3YWl0IHRoaXMuYm9vdCgpO1xuICAgIGlmICghaXNVaUNsaWVudFJ1bm5pbmcpIHtcbiAgICAgIGF3YWl0IHRoaXMuc3RhcnRVSUNsaWVudChvcHRzKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQm9vdHMgc2ltdWxhdG9yIGlmIG5vdCBhbHJlYWR5IGJvb3RlZC5cbiAgICovXG4gIGFzeW5jIGJvb3QgKCkge1xuICAgIGxvZy5pbmZvKGBCb290aW5nIFNpbXVsYXRvciB3aXRoIFVESUQgJyR7dGhpcy51ZGlkfScuLi5gKTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgcmV0cnlJbnRlcnZhbCgzLCAyMDAwLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgdGhpcy5zaW1jdGwuYm9vdERldmljZSgpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaWYgKCFfLmluY2x1ZGVzKGUuc3RkZXJyLCAnVW5hYmxlIHRvIGJvb3QgZGV2aWNlIGluIGN1cnJlbnQgc3RhdGU6IEJvb3RlZCcpKSB7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsb2cuZGVidWcoYFNpbXVsYXRvciB3aXRoIFVESUQgJyR7dGhpcy51ZGlkfScgaXMgYWxyZWFkeSBpbiBCb290ZWQgc3RhdGVgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBsb2cud2FybihlcnIuc3RkZXJyIHx8IGVyci5tZXNzYWdlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUGVyZm9ybSB2ZXJpZmljYXRpb24gb2YgZGV2aWNlIHByZWZlcmVuY2VzIGNvcnJlY3RuZXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge0RldmljZVByZWZlcmVuY2VzfSBwcmVmcyBbe31dIC0gVGhlIHByZWZlcmVuY2VzIHRvIGJlIHZlcmlmaWVkXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBJZiBhbnkgb2YgdGhlIGdpdmVuIHByZWZlcmVuY2UgdmFsdWVzIGRvZXMgbm90IG1hdGNoIHRoZSBleHBlY3RlZFxuICAgKiBmb3JtYXQuXG4gICAqL1xuICB2ZXJpZnlEZXZpY2VQcmVmZXJlbmNlcyAocHJlZnMgPSB7fSkge1xuICAgIGlmIChfLmlzRW1wdHkocHJlZnMpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKHByZWZzLlNpbXVsYXRvcldpbmRvd0xhc3RTY2FsZSkpIHtcbiAgICAgIGlmICghXy5pc051bWJlcihwcmVmcy5TaW11bGF0b3JXaW5kb3dMYXN0U2NhbGUpIHx8IHByZWZzLlNpbXVsYXRvcldpbmRvd0xhc3RTY2FsZSA8PSAwKSB7XG4gICAgICAgIGxvZy5lcnJvckFuZFRocm93KGBTaW11bGF0b3JXaW5kb3dMYXN0U2NhbGUgaXMgZXhwZWN0ZWQgdG8gYmUgYSBwb3NpdGl2ZSBmbG9hdCB2YWx1ZS4gYCArXG4gICAgICAgICAgYCcke3ByZWZzLlNpbXVsYXRvcldpbmRvd0xhc3RTY2FsZX0nIGlzIGFzc2lnbmVkIGluc3RlYWQuYCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKHByZWZzLlNpbXVsYXRvcldpbmRvd0NlbnRlcikpIHtcbiAgICAgIC8vIGh0dHBzOi8vcmVnZXgxMDEuY29tL3IvMlpYT2lqLzJcbiAgICAgIGNvbnN0IHZlcmlmaWNhdGlvblBhdHRlcm4gPSAvey0/XFxkKyhcXC5cXGQrKT8sLT9cXGQrKFxcLlxcZCspP30vO1xuICAgICAgaWYgKCFfLmlzU3RyaW5nKHByZWZzLlNpbXVsYXRvcldpbmRvd0NlbnRlcikgfHwgIXZlcmlmaWNhdGlvblBhdHRlcm4udGVzdChwcmVmcy5TaW11bGF0b3JXaW5kb3dDZW50ZXIpKSB7XG4gICAgICAgIGxvZy5lcnJvckFuZFRocm93KGBTaW11bGF0b3JXaW5kb3dDZW50ZXIgaXMgZXhwZWN0ZWQgdG8gbWF0Y2ggXCJ7ZmxvYXRYUG9zaXRpb24sZmxvYXRZUG9zaXRpb259XCIgZm9ybWF0ICh3aXRob3V0IHNwYWNlcykuIGAgK1xuICAgICAgICAgIGAnJHtwcmVmcy5TaW11bGF0b3JXaW5kb3dDZW50ZXJ9JyBpcyBhc3NpZ25lZCBpbnN0ZWFkLmApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghXy5pc1VuZGVmaW5lZChwcmVmcy5TaW11bGF0b3JXaW5kb3dPcmllbnRhdGlvbikpIHtcbiAgICAgIGNvbnN0IGFjY2VwdGFibGVWYWx1ZXMgPSBbJ1BvcnRyYWl0JywgJ0xhbmRzY2FwZUxlZnQnLCAnUG9ydHJhaXRVcHNpZGVEb3duJywgJ0xhbmRzY2FwZVJpZ2h0J107XG4gICAgICBpZiAoYWNjZXB0YWJsZVZhbHVlcy5pbmRleE9mKHByZWZzLlNpbXVsYXRvcldpbmRvd09yaWVudGF0aW9uKSA9PT0gLTEpIHtcbiAgICAgICAgbG9nLmVycm9yQW5kVGhyb3coYFNpbXVsYXRvcldpbmRvd09yaWVudGF0aW9uIGlzIGV4cGVjdGVkIHRvIGJlIG9uZSBvZiAke2FjY2VwdGFibGVWYWx1ZXN9LiBgICtcbiAgICAgICAgICBgJyR7cHJlZnMuU2ltdWxhdG9yV2luZG93T3JpZW50YXRpb259JyBpcyBhc3NpZ25lZCBpbnN0ZWFkLmApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghXy5pc1VuZGVmaW5lZChwcmVmcy5TaW11bGF0b3JXaW5kb3dSb3RhdGlvbkFuZ2xlKSkge1xuICAgICAgaWYgKCFfLmlzTnVtYmVyKHByZWZzLlNpbXVsYXRvcldpbmRvd1JvdGF0aW9uQW5nbGUpKSB7XG4gICAgICAgIGxvZy5lcnJvckFuZFRocm93KGBTaW11bGF0b3JXaW5kb3dSb3RhdGlvbkFuZ2xlIGlzIGV4cGVjdGVkIHRvIGJlIGEgdmFsaWQgbnVtYmVyLiBgICtcbiAgICAgICAgICBgJyR7cHJlZnMuU2ltdWxhdG9yV2luZG93Um90YXRpb25BbmdsZX0nIGlzIGFzc2lnbmVkIGluc3RlYWQuYCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgY29tbW9uIGlPUyBTaW11bGF0b3IgcHJlZmVyZW5jZXMgZmlsZSB3aXRoIG5ldyB2YWx1ZXMuXG4gICAqIEl0IGlzIG5lY2Vzc2FyeSB0byByZXN0YXJ0IHRoZSBjb3JyZXNwb25kaW5nIFNpbXVsYXRvciBiZWZvcmVcbiAgICogdGhlc2UgY2hhbmdlcyBhcmUgYXBwbGllZC5cbiAgICpcbiAgICogQHBhcmFtIHtEZXZpY2VQcmVmZXJlbmNlc30gZGV2aWNlUHJlZnMgW3t9XSAtIFRoZSBtYXBwaW5nLCB3aGljaCByZXByZXNlbnRzIG5ldyBkZXZpY2UgcHJlZmVyZW5jZSB2YWx1ZXNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciB0aGUgZ2l2ZW4gU2ltdWxhdG9yLlxuICAgKiBAcGFyYW0ge0NvbW1vblByZWZlcmVuY2VzfSBjb21tb25QcmVmcyBbe31dIC0gVGhlIG1hcHBpbmcsIHdoaWNoIHJlcHJlc2VudHMgbmV3IGNvbW1vbiBwcmVmZXJlbmNlIHZhbHVlc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIGFsbCBTaW11bGF0b3JzLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBwcmVmZXJlbmNlcyB3ZXJlIHN1Y2Nlc3NmdWxseSB1cGRhdGVkLlxuICAgKi9cbiAgYXN5bmMgdXBkYXRlUHJlZmVyZW5jZXMgKGRldmljZVByZWZzID0ge30sIGNvbW1vblByZWZzID0ge30pIHtcbiAgICBpZiAoIV8uaXNFbXB0eShkZXZpY2VQcmVmcykpIHtcbiAgICAgIGxvZy5kZWJ1ZyhgU2V0dGluZyBwcmVmZXJlbmNlcyBvZiAke3RoaXMudWRpZH0gU2ltdWxhdG9yIHRvICR7SlNPTi5zdHJpbmdpZnkoZGV2aWNlUHJlZnMpfWApO1xuICAgIH1cbiAgICBpZiAoIV8uaXNFbXB0eShjb21tb25QcmVmcykpIHtcbiAgICAgIGxvZy5kZWJ1ZyhgU2V0dGluZyBjb21tb24gU2ltdWxhdG9yIHByZWZlcmVuY2VzIHRvICR7SlNPTi5zdHJpbmdpZnkoY29tbW9uUHJlZnMpfWApO1xuICAgIH1cbiAgICBjb25zdCBob21lRm9sZGVyUGF0aCA9IHByb2Nlc3MuZW52LkhPTUU7XG4gICAgaWYgKCFob21lRm9sZGVyUGF0aCkge1xuICAgICAgbG9nLndhcm4oYENhbm5vdCBnZXQgdGhlIHBhdGggdG8gSE9NRSBmb2xkZXIgZnJvbSB0aGUgcHJvY2VzcyBlbnZpcm9ubWVudC4gYCArXG4gICAgICAgIGBJZ25vcmluZyBTaW11bGF0b3IgcHJlZmVyZW5jZXMgdXBkYXRlLmApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLnZlcmlmeURldmljZVByZWZlcmVuY2VzKGRldmljZVByZWZzKTtcbiAgICBjb25zdCBwbGlzdFBhdGggPSBwYXRoLnJlc29sdmUoaG9tZUZvbGRlclBhdGgsICdMaWJyYXJ5JywgJ1ByZWZlcmVuY2VzJywgJ2NvbS5hcHBsZS5pcGhvbmVzaW11bGF0b3IucGxpc3QnKTtcbiAgICBpZiAoIWF3YWl0IGZzLmhhc0FjY2VzcyhwbGlzdFBhdGgpKSB7XG4gICAgICBsb2cud2FybihgU2ltdWxhdG9yIHByZWZlcmVuY2VzIGZpbGUgJyR7cGxpc3RQYXRofScgaXMgbm90IGFjY2Vzc2libGUuIGAgK1xuICAgICAgICBgSWdub3JpbmcgU2ltdWxhdG9yIHByZWZlcmVuY2VzIHVwZGF0ZS5gKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbGV0IG5ld1ByZWZzID0ge307XG4gICAgaWYgKCFfLmlzRW1wdHkoZGV2aWNlUHJlZnMpKSB7XG4gICAgICBuZXdQcmVmcy5EZXZpY2VQcmVmZXJlbmNlcyA9IHtbdGhpcy51ZGlkLnRvVXBwZXJDYXNlKCldOiBkZXZpY2VQcmVmc307XG4gICAgfVxuICAgIG5ld1ByZWZzID0gXy5tZXJnZShuZXdQcmVmcywgY29tbW9uUHJlZnMpO1xuICAgIHJldHVybiBhd2FpdCBwcmVmZXJlbmNlc1BsaXN0R3VhcmQuYWNxdWlyZShTaW11bGF0b3JYY29kZTkubmFtZSwgYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgY3VycmVudFBsaXN0Q29udGVudCA9IGF3YWl0IHBsaXN0LnBhcnNlUGxpc3RGaWxlKHBsaXN0UGF0aCk7XG4gICAgICAgIGF3YWl0IHBsaXN0LnVwZGF0ZVBsaXN0RmlsZShwbGlzdFBhdGgsIF8ubWVyZ2UoY3VycmVudFBsaXN0Q29udGVudCwgbmV3UHJlZnMpLCB0cnVlKTtcbiAgICAgICAgbG9nLmRlYnVnKGBVcGRhdGVkICR7dGhpcy51ZGlkfSBTaW11bGF0b3IgcHJlZmVyZW5jZXMgYXQgJyR7cGxpc3RQYXRofScgd2l0aCAke0pTT04uc3RyaW5naWZ5KG5ld1ByZWZzKX1gKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGxvZy53YXJuKGBDYW5ub3QgdXBkYXRlICR7dGhpcy51ZGlkfSBTaW11bGF0b3IgcHJlZmVyZW5jZXMgYXQgJyR7cGxpc3RQYXRofScuIGAgK1xuICAgICAgICAgICAgICAgICBgVHJ5IHRvIGRlbGV0ZSB0aGUgZmlsZSBtYW51YWxseSBpbiBvcmRlciB0byByZXNldCBpdC4gT3JpZ2luYWwgZXJyb3I6ICR7ZS5tZXNzYWdlfWApO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU2h1dCBkb3duIHRoZSBjdXJyZW50IFNpbXVsYXRvci5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBhc3luYyBzaHV0ZG93biAoKSB7XG4gICAgY29uc3Qge3N0YXRlfSA9IGF3YWl0IHRoaXMuc3RhdCgpO1xuICAgIGlmIChzdGF0ZSA9PT0gJ1NodXRkb3duJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhd2FpdCByZXRyeUludGVydmFsKDUsIDUwMCwgdGhpcy5zaW1jdGwuc2h1dGRvd25EZXZpY2UuYmluZCh0aGlzLnNpbWN0bCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc2V0IHRoZSBjdXJyZW50IFNpbXVsYXRvciB0byB0aGUgY2xlYW4gc3RhdGUuXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgYXN5bmMgY2xlYW4gKCkge1xuICAgIGxvZy5pbmZvKGBDbGVhbmluZyBzaW11bGF0b3IgJHt0aGlzLnVkaWR9YCk7XG4gICAgYXdhaXQgdGhpcy5zaW1jdGwuZXJhc2VEZXZpY2UoMTAwMDApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0ZG9jXG4gICAqIEBvdmVycmlkZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYXN5bmMgX2FjdGl2YXRlV2luZG93ICgpIHtcbiAgICBsZXQgc2VsZk5hbWU7XG4gICAgbGV0IHNlbGZTZGs7XG4gICAgbGV0IGJvb3RlZERldmljZXNDb3VudCA9IDA7XG4gICAgZm9yIChjb25zdCBbc2RrLCBkZXZpY2VBcnJdIG9mIF8udG9QYWlycyhhd2FpdCB0aGlzLnNpbWN0bC5nZXREZXZpY2VzKCkpKSB7XG4gICAgICBmb3IgKGNvbnN0IHtzdGF0ZSwgdWRpZCwgbmFtZX0gb2YgZGV2aWNlQXJyKSB7XG4gICAgICAgIGlmIChzdGF0ZSA9PT0gJ0Jvb3RlZCcpIHtcbiAgICAgICAgICBib290ZWREZXZpY2VzQ291bnQrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXNlbGZOYW1lICYmIHVkaWQgPT09IHRoaXMudWRpZCkge1xuICAgICAgICAgIHNlbGZTZGsgPSBzZGs7XG4gICAgICAgICAgc2VsZk5hbWUgPSBuYW1lO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChib290ZWREZXZpY2VzQ291bnQgPCAyKSB7XG4gICAgICByZXR1cm4gYXdhaXQgc3VwZXIuX2FjdGl2YXRlV2luZG93KCk7XG4gICAgfVxuXG4gICAgLy8gVGhlcmUgYXJlIHBvdGVudGlhbGx5IG1vcmUgdGhhdCBvbmUgU2ltdWxhdG9yIHdpbmRvd1xuICAgIHJldHVybiBgXG4gICAgICB0ZWxsIGFwcGxpY2F0aW9uIFwiU3lzdGVtIEV2ZW50c1wiXG4gICAgICAgIHRlbGwgcHJvY2VzcyBcIlNpbXVsYXRvclwiXG4gICAgICAgICAgc2V0IGZyb250bW9zdCB0byBmYWxzZVxuICAgICAgICAgIHNldCBmcm9udG1vc3QgdG8gdHJ1ZVxuICAgICAgICAgIGNsaWNrIChtZW51IGl0ZW0gMSB3aGVyZSAoaXRzIG5hbWUgY29udGFpbnMgXCIke3NlbGZOYW1lfSBcIiBhbmQgaXRzIG5hbWUgY29udGFpbnMgXCIke3NlbGZTZGt9XCIpKSBvZiBtZW51IDEgb2YgbWVudSBiYXIgaXRlbSBcIldpbmRvd1wiIG9mIG1lbnUgYmFyIDFcbiAgICAgICAgZW5kIHRlbGxcbiAgICAgIGVuZCB0ZWxsXG4gICAgYDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdGRvY1xuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGFzeW5jIGlzQmlvbWV0cmljRW5yb2xsZWQgKCkge1xuICAgIGNvbnN0IHtzdGRvdXR9ID0gYXdhaXQgdGhpcy5zaW1jdGwuc3Bhd25Qcm9jZXNzKFtcbiAgICAgICdub3RpZnl1dGlsJyxcbiAgICAgICctZycsIEVOUk9MTE1FTlRfTk9USUZJQ0FUSU9OX1JFQ0VJVkVSXG4gICAgXSk7XG4gICAgY29uc3QgbWF0Y2ggPSAobmV3IFJlZ0V4cChgJHtfLmVzY2FwZVJlZ0V4cChFTlJPTExNRU5UX05PVElGSUNBVElPTl9SRUNFSVZFUil9XFxcXHMrKFswMV0pYCkpXG4gICAgICAuZXhlYyhzdGRvdXQpO1xuICAgIGlmICghbWF0Y2gpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHBhcnNlIGJpb21ldHJpYyBlbnJvbGxtZW50IHN0YXRlIGZyb20gJyR7c3Rkb3V0fSdgKTtcbiAgICB9XG4gICAgbG9nLmluZm8oYEN1cnJlbnQgYmlvbWV0cmljIGVucm9sbGVkIHN0YXRlIGZvciAke3RoaXMudWRpZH0gU2ltdWxhdG9yOiAke21hdGNoWzFdfWApO1xuICAgIHJldHVybiBtYXRjaFsxXSA9PT0gJzEnO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0ZG9jXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgYXN5bmMgZW5yb2xsQmlvbWV0cmljIChpc0VuYWJsZWQgPSB0cnVlKSB7XG4gICAgbG9nLmRlYnVnKGBTZXR0aW5nIGJpb21ldHJpYyBlbnJvbGxlZCBzdGF0ZSBmb3IgJHt0aGlzLnVkaWR9IFNpbXVsYXRvciB0byAnJHtpc0VuYWJsZWQgPyAnZW5hYmxlZCcgOiAnZGlzYWJsZWQnfSdgKTtcbiAgICBhd2FpdCB0aGlzLnNpbWN0bC5zcGF3blByb2Nlc3MoW1xuICAgICAgJ25vdGlmeXV0aWwnLFxuICAgICAgJy1zJywgRU5ST0xMTUVOVF9OT1RJRklDQVRJT05fUkVDRUlWRVIsIGlzRW5hYmxlZCA/ICcxJyA6ICcwJ1xuICAgIF0pO1xuICAgIGF3YWl0IHRoaXMuc2ltY3RsLnNwYXduUHJvY2VzcyhbXG4gICAgICAnbm90aWZ5dXRpbCcsXG4gICAgICAnLXAnLCBFTlJPTExNRU5UX05PVElGSUNBVElPTl9SRUNFSVZFUlxuICAgIF0pO1xuICAgIGlmIChhd2FpdCB0aGlzLmlzQmlvbWV0cmljRW5yb2xsZWQoKSAhPT0gaXNFbmFibGVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBzZXQgYmlvbWV0cmljIGVucm9sbGVkIHN0YXRlIGZvciAke3RoaXMudWRpZH0gU2ltdWxhdG9yIHRvICcke2lzRW5hYmxlZCA/ICdlbmFibGVkJyA6ICdkaXNhYmxlZCd9J2ApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyBhIG5vdGlmaWNhdGlvbiB0byBtYXRjaC9ub3QgbWF0Y2ggdGhlIHBhcnRpY3VsYXIgYmlvbWV0cmljLlxuICAgKiBAb3ZlcnJpZGVcbiAgICpcbiAgICogQHBhcmFtIHs/Ym9vbGVhbn0gc2hvdWxkTWF0Y2ggW3RydWVdIC0gU2V0IGl0IHRvIHRydWUgb3IgZmFsc2UgaW4gb3JkZXIgdG8gZW11bGF0ZVxuICAgKiBtYXRjaGluZy9ub3QgbWF0Y2hpbmcgdGhlIGNvcnJlc3BvbmRpbmcgYmlvbWV0cmljXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gYmlvbWV0cmljTmFtZSBbdG91Y2hJZF0gLSBFaXRoZXIgdG91Y2hJZCBvciBmYWNlSWQgKGZhY2VJZCBpcyBvbmx5IGF2YWlsYWJsZSBzaW5jZSBpT1MgMTEpXG4gICAqL1xuICBhc3luYyBzZW5kQmlvbWV0cmljTWF0Y2ggKHNob3VsZE1hdGNoID0gdHJ1ZSwgYmlvbWV0cmljTmFtZSA9ICd0b3VjaElkJykge1xuICAgIGNvbnN0IGRvbWFpbkNvbXBvbmVudCA9IHRvQmlvbWV0cmljRG9tYWluQ29tcG9uZW50KGJpb21ldHJpY05hbWUpO1xuICAgIGNvbnN0IGRvbWFpbiA9IGBjb20uYXBwbGUuQmlvbWV0cmljS2l0X1NpbS4ke2RvbWFpbkNvbXBvbmVudH0uJHtzaG91bGRNYXRjaCA/ICcnIDogJ25vJ31tYXRjaGA7XG4gICAgYXdhaXQgdGhpcy5zaW1jdGwuc3Bhd25Qcm9jZXNzKFtcbiAgICAgICdub3RpZnl1dGlsJyxcbiAgICAgICctcCcsIGRvbWFpblxuICAgIF0pO1xuICAgIGxvZy5pbmZvKGBTZW50IG5vdGlmaWNhdGlvbiAke2RvbWFpbn0gdG8gJHtzaG91bGRNYXRjaCA/ICdtYXRjaCcgOiAnbm90IG1hdGNoJ30gJHtiaW9tZXRyaWNOYW1lfSBiaW9tZXRyaWMgYCArXG4gICAgICBgZm9yICR7dGhpcy51ZGlkfSBTaW11bGF0b3JgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGFzeW5jIGdldExhdW5jaERhZW1vbnNSb290ICgpIHtcbiAgICBjb25zdCBkZXZSb290ID0gYXdhaXQgZ2V0RGV2ZWxvcGVyUm9vdCgpO1xuICAgIHJldHVybiBwYXRoLnJlc29sdmUoZGV2Um9vdCxcbiAgICAgICdQbGF0Zm9ybXMvaVBob25lT1MucGxhdGZvcm0vRGV2ZWxvcGVyL0xpYnJhcnkvQ29yZVNpbXVsYXRvci9Qcm9maWxlcy9SdW50aW1lcy9pT1Muc2ltcnVudGltZS9Db250ZW50cy9SZXNvdXJjZXMvUnVudGltZVJvb3QvU3lzdGVtL0xpYnJhcnkvTGF1bmNoRGFlbW9ucycpO1xuICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgU2ltdWxhdG9yWGNvZGU5O1xuIl0sImZpbGUiOiJsaWIvc2ltdWxhdG9yLXhjb2RlLTkuanMiLCJzb3VyY2VSb290IjoiLi4vLi4ifQ==
